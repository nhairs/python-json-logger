{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python JSON Logger","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This library is provided to allow standard python logging to output log data as json objects. With JSON we can make our logs more readable by machines and we can stop writing custom parsers for syslog type records.</p> <p>Warning</p> <p>This repository is a maintained fork of madzak/python-json-logger pending a PEP 541 request for the PyPI package.  The future direction of the project is being discussed here.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO?: TODO.</li> <li>Multiple Encoders: In addition to the standard libary's <code>json</code> module, also supports 3rd party encoders: <code>orjson</code>, <code>msgspec</code></li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Follow our Quickstart Guide.</p> TLDR<pre><code>import logging\nfrom pythonjsonlogger.json import JsonFormatter\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nhandler = logging.StreamHandler()\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogger.info(\"Logging using pythonjsonlogger!\", extra={\"more_data\": True})\n\n# {\"message\": \"Logging using pythonjsonlogger!\", \"more_data\": true}\n</code></pre>"},{"location":"#bugs-feature-requests-etc","title":"Bugs, Feature Requests etc","text":"<p>Please submit an issue on github.</p> <p>In the case of bug reports, please help us help you by following best practices <sup>1</sup> <sup>2</sup>.</p> <p>In the case of feature requests, please provide background to the problem you are trying to solve so to help find a solution that makes the most sense for the library as well as your usecase.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD 2 Clause License - see <code>LICENSE</code></p>"},{"location":"#authors-and-maintainers","title":"Authors and Maintainers","text":"<p>This project was originally authored by Zakaria Zajac and our wonderful contributors</p> <p>It is currently maintained by:</p> <ul> <li>Nicholas Hairs - nicholashairs.com</li> </ul>"},{"location":"changelog/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#310rc3-2023-05-03","title":"3.1.0.rc3 - 2023-05-03","text":"<p>This splits common funcitonality out to allow supporting other JSON encoders. Although this is a large refactor, backwards compatibility has been maintained.</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>pythonjsonlogger.core</code> - more details below.</li> <li><code>pythonjsonlogger.defaults</code> module that provides many functions for handling unsupported types.</li> <li>Orjson encoder support via <code>pythonjsonlogger.orjson.OrjsonFormatter</code> with the following additions:<ul> <li>bytes are URL safe base64 encoded.</li> <li>Exceptions are \"pretty printed\" using the exception name and message e.g. <code>\"ValueError: bad value passed\"</code></li> <li>Enum values use their value, Enum classes now return all values as a list.</li> <li>Tracebacks are supported</li> <li>Classes (aka types) are support</li> <li>Will fallback on <code>__str__</code> if available, else <code>__repr__</code> if available, else will use <code>__could_not_encode__</code></li> </ul> </li> <li>MsgSpec encoder support via <code>pythonjsonlogger.msgspec.MsgspecFormatter</code> with the following additions:<ul> <li>Exceptions are \"pretty printed\" using the exception name and message e.g. <code>\"ValueError: bad value passed\"</code></li> <li>Enum classes now return all values as a list.</li> <li>Tracebacks are supported</li> <li>Classes (aka types) are support</li> <li>Will fallback on <code>__str__</code> if available, else <code>__repr__</code> if available, else will use <code>__could_not_encode__</code></li> <li>Note: msgspec only supprts enum values of type <code>int</code> or <code>str</code> jcrist/msgspec#680</li> </ul> </li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li><code>pythonjsonlogger.jsonlogger</code> has been moved to <code>pythonjsonlogger.json</code> with core functionality moved to <code>pythonjsonlogger.core</code>.</li> <li><code>pythonjsonlogger.core.BaseJsonFormatter</code> properly supports all <code>logging.Formatter</code> arguments:<ul> <li><code>fmt</code> is unchanged.</li> <li><code>datefmt</code> is unchanged.</li> <li><code>style</code> can now support non-standard arguments by setting <code>validate</code> to <code>False</code></li> <li><code>validate</code> allows non-standard <code>style</code> arguments or prevents calling <code>validate</code> on standard <code>style</code> arguments.</li> <li><code>default</code> is ignored.</li> </ul> </li> <li><code>pythonjsonlogger.json.JsonFormatter</code> default encodings changed:<ul> <li>bytes are URL safe base64 encoded.</li> <li>Exception formatting detected using <code>BaseException</code> instead of <code>Exception</code>. Now \"pretty prints\" the exception using the exception name and message e.g. <code>\"ValueError: bad value passed\"</code></li> <li>Dataclasses are now supported</li> <li>Enum values now use their value, Enum classes now return all values as a list.</li> <li>Will fallback on <code>__str__</code> if available, else <code>__repr__</code> if available, else will use <code>__could_not_encode__</code></li> </ul> </li> <li>Renaming fields now preserves order (#7) and ignores missing fields (#6).</li> <li>Documentation<ul> <li>Generated documentation using <code>mkdocs</code> is stored in <code>docs/</code></li> <li>Documentation within <code>README.md</code> has been moved to <code>docs/index.md</code> and <code>docs/qucikstart.md</code>.</li> <li><code>CHANGELOG.md</code> has been moved to <code>docs/change-log.md</code></li> <li><code>SECURITY.md</code> has been moved and replaced with a symbolic link to <code>docs/security.md</code>.</li> </ul> </li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>pythonjsonlogger.jsonlogger</code> is now <code>pythonjsonlogger.json</code></li> <li><code>pythonjsonlogger.jsonlogger.RESERVED_ATTRS</code> is now <code>pythonjsonlogger.core.RESERVED_ATTRS</code>.</li> <li><code>pythonjsonlogger.jsonlogger.merge_record_extra</code> is now <code>pythonjsonlogger.core.merge_record_extra</code>.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Python 3.7 support dropped</li> <li><code>pythonjsonlogger.jsonlogger.JsonFormatter._str_to_fn</code> replaced with <code>pythonjsonlogger.core.str_to_object</code>.</li> </ul>"},{"location":"changelog/#301-2023-04-01","title":"3.0.1 - 2023-04-01","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Fix spelling of parameter <code>json_serialiser</code> -&gt; <code>json_serializer</code> (#8) - @juliangilbey</li> </ul>"},{"location":"changelog/#300-2024-03-25","title":"3.0.0 - 2024-03-25","text":"<p>Note: using new major version to seperate changes from this fork and the original (upstream). See #1 for details.</p>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Update supported Python versions - @nhairs<ul> <li>Drop 3.6</li> <li>The following versions are supported and tested:<ul> <li>CPython 3.7-3.12 (ubuntu, windows, mac)</li> <li>PyPy 3.7-3.10 (ubuntu, wundows, mac)</li> </ul> </li> <li><code>RESERVED_ATTRS</code> is now a list and version dependent</li> </ul> </li> <li>Fix <code>JsonFormatter.__init__</code> return type (<code>None</code>) - @nhairs</li> <li>Moved to <code>pyproject.toml</code> - @nhairs</li> <li>Update linting and testing - @nhairs<ul> <li>Split lint and test steps in GHA</li> <li>Use validate-pyproject, black, pylint, mypy</li> </ul> </li> </ul>"},{"location":"changelog/#207-2023-02-21","title":"2.0.7 - 2023-02-21","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Fix inclusion of py.typed in pip packages - @sth</li> <li>Added pytest support with test file rename. Migrated to assertEqual</li> </ul>"},{"location":"changelog/#206-2023-02-14","title":"2.0.6 - 2023-02-14","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Parameter <code>rename_fields</code> in merge_record_extra is now optional - @afallou</li> </ul>"},{"location":"changelog/#205-2023-02-12","title":"2.0.5 - 2023-02-12","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Allow reserved attrs to be renamed - @henkhogan</li> <li>Support added for Python 3.11</li> <li>Now verifying builds in Pypy 3.9 as well</li> <li>Type annotations are now in the package - @louis-jaris</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Fix rename_fields for exc_info - @guilhermeferrari</li> <li>Cleaned up test file for PEP8 - @lopagela</li> <li>Cleaned up old Python 2 artifacts - @louis-jaris</li> <li>Dropped Python 3.5 support - @idomozes</li> <li>Moved type check via tox into 3.11 run only</li> <li>Added test run in Python3.6 (will keep for a little while longer, but it's EOL so upgrade)</li> </ul>"},{"location":"changelog/#204-2022-07-11","title":"2.0.4 - 2022-07-11","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Fix too strict regex for percentage style logging - @aberres</li> </ul>"},{"location":"changelog/#203-2022-07-08","title":"2.0.3 - 2022-07-08","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Add PEP 561 marker/basic mypy configuration. - @bringhurst</li> <li>Workaround logging.LogRecord.msg type of string. - @bringhurst</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Changed a link archive of the reference page in case it's down. - @ahonnecke</li> <li>Removed unnecessary try-except around OrderedDict usage - @sozofaan</li> <li>Update documentation link to json module + use https - @deronnax</li> <li>Dropped 3.5 support. - @bringhurst</li> </ul>"},{"location":"changelog/#202-2021-07-27","title":"2.0.2 - 2021-07-27","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Officially supporting 3.9 - @felixonmars.</li> <li>You can now add static fields to log objects - @cosimomeli.</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Dropped 3.4 support.</li> <li>Dropped Travis CI for Github Actions.</li> <li>Wheel should build for python 3 instead of just 3.4 now.</li> </ul>"},{"location":"changelog/#201-2020-10-12","title":"2.0.1 - 2020-10-12","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Support Pypi long descripton - @ereli-cb</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>You can now rename output fields - @schlitzered</li> </ul>"},{"location":"changelog/#200-2020-09-26","title":"2.0.0 - 2020-09-26","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>New Changelog</li> <li>Added timezone support to timestamps - @lalten</li> <li>Refactored log record to function - @georgysavva</li> <li>Add python 3.8 support - @tommilligan</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Support for Python 2.7</li> <li>Debian directory</li> </ul>"},{"location":"changelog/#0111-2019-03-29","title":"0.1.11 - 2019-03-29","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Support for Python 3.7</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>'stack_info' flag in logging calls is now respected in JsonFormatter by @ghShu</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome!</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>In general we follow the Python Software Foundation Code of Conduct.</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<p>0. Before you begin</p> <p>If you're not familiar with contributing to open source software, start by reading this guide.</p> <p>Be aware that anything you contribute will be licenced under the project's licence. If you are making a change as a part of your job, be aware that your employer might own your work and you'll need their permission in order to licence the code.</p>"},{"location":"contributing/#1-find-something-to-work-on","title":"1. Find something to work on","text":"<p>Where possible it's best to stick to established issues where discussion has already taken place. Contributions that haven't come from a discussed issue are less likely to be accepted.</p> <p>The following are things that can be worked on without an existing issue:</p> <ul> <li>Updating documentation. This includes fixing in-code documentation / comments, and the overall docs.</li> <li>Small changes that don't change functionality such as refactoring or adding / updating tests.</li> </ul>"},{"location":"contributing/#2-fork-the-repository-and-make-your-changes","title":"2. Fork the repository and make your changes","text":"<p>We don't have styling documentation, so where possible try to match existing code. This includes the use of \"headings\" and \"dividers\" (this will make sense when you look at the code).</p> <p>All devlopment tooling can be installed (usually into a virtual environment), using the <code>dev</code> optiontal dependency:</p> <pre><code>pip install -e '.[dev]'`\n</code></pre> <p>Before creating your pull request you'll want to format your code and run the linters and tests:</p> <pre><code># Format\nblack src tests\n\n# Lint\npylint --output-format=colorized src\nmypy src tests\n\n# Tests\npytest\n</code></pre> <p>If making changes to the documentation you can preview the changes locally using <code>mkdocs</code>. Changes to the README can be previewed using <code>grip</code> (not included in <code>dev</code> dependencies).</p> <pre><code>mkdocs serve\n</code></pre> <p>Note</p> <p>In general we will always squash merge pull requests so you do not need to worry about a \"clean\" commit history.</p>"},{"location":"contributing/#3-checklist","title":"3. Checklist","text":"<p>Before pushing and creating your pull request, you should make sure you've done the following:</p> <ul> <li>Updated any relevant tests.</li> <li>Formatted your code and run the linters and tests.</li> <li>Updated the version number in <code>pyproject.toml</code>. In general using a <code>.devN</code> suffix is acceptable.   This is not required for changes that do no affect the code such as documentation.</li> <li>Add details of the changes to the change log (<code>docs/change-log.md</code>), creating a new section if needed.</li> <li>Add notes for new / changed features in the relevant docstring.</li> </ul> <p>4. Create your pull request</p> <p>When creating your pull request be aware that the title and description will be used for the final commit so pay attention to them.</p> <p>Your pull request description should include the following:</p> <ul> <li>Why the pull request is being made</li> <li>Summary of changes</li> <li>How the pull request was tested - especially if not covered by unit testing.</li> </ul> <p>Once you've submitted your pull request make sure that all CI jobs are passing. Pull requests will failing jobs will not be reviewed.</p>"},{"location":"contributing/#5-code-review","title":"5. Code review","text":"<p>Your code will be reviewed by a maintainer.</p> <p>If you're not familiar with code review start by reading this guide.</p> <p>Remember you are not your work</p> <p>You might be asked to explain or justify your choices. This is not a criticism of your value as a person!</p> <p>Often this is because there are multiple ways to solve the same problem and the reviewer would like to understand more about the way you solved.</p>"},{"location":"contributing/#common-topics","title":"Common Topics","text":""},{"location":"contributing/#adding-a-new-encoder","title":"Adding a new encoder","text":"<p>New encoders may be added, however how popular / common a library is will be taken into consideration before being added.</p>"},{"location":"contributing/#versioning-and-breaking-compatability","title":"Versioning and breaking compatability","text":"<p>This project uses semantic versioning.</p> <p>In general backwards compatability is always preferred. This library is widely used and not particularly sophisticated, there must be a good reason for breaking changes.</p>"},{"location":"contributing/#spelling","title":"Spelling","text":"<p>The original implementation of this project used US spelling so it will continue to use US spelling for all code.</p> <p>Documentation is more flexible and may use a variety of English spellings.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Recipies for common tasks.</p>"},{"location":"cookbook/#include-all-fields","title":"Include all fields","text":"<p>This can be achieved by setting <code>reserved_attrs=[]</code> when creating the formatter.</p>"},{"location":"cookbook/#custom-styles","title":"Custom Styles","text":"<p>It is possible to support custom <code>style</code>s by setting <code>validate=False</code> and overriding the <code>parse</code> method.</p> <p>For example:</p> <pre><code>class CommaSupport(JsonFormatter):\n    def parse(self) -&gt; list[str]:\n        if isinstance(self._style, str) and self._style == \",\":\n            return self._fmt.split(\",\")\n        return super().parse()\n\nformatter = CommaSupport(\"message,asctime\", style=\",\", validate=False)\n</code></pre>"},{"location":"cookbook/#modifying-the-logged-data","title":"Modifying the logged data","text":"<p>You can modify the <code>dict</code> of data that will be logged by overriding the <code>process_log_record</code> method to modify fields before they are serialized to JSON.</p> <pre><code>class SillyFormatter(JsonFormatter):\n    def process_log_record(log_record):\n        new_record = {k[::-1]: v for k, v in log_record.items()}\n        return new_record\n</code></pre>"},{"location":"cookbook/#request-trace-ids","title":"Request / Trace IDs","text":"<p>There are many ways to add consistent request IDs to your logging. The exact method will depend on your needs and application.</p> <pre><code>import logging\nimport uuid\nfrom pythonjsonlogger.json import JsonFormatter\n\n## Setup\n## -----------------------------------------------------------------------------\nlogger = logging.getLogger(\"test\")\nlogger.setLevel(logging.INFO)\nhandler = logging.StreamHandler()\nlogger.addHandler(handler)\n\n## Solution 1\n## -----------------------------------------------------------------------------\nformatter = JsonFormatter()\nhandler.setFormatter(formatter)\n\ndef main_1():\n    print(\"========== MAIN 1 ==========\")\n    for i in range(3):\n        request_id = uuid.uuid4().hex\n        logger.info(\"loop start\", extra={\"request_id\": request_id})\n        logger.info(f\"loop {i}\", extra={\"request_id\": request_id})\n        logger.info(\"loop end\", extra={\"request_id\": request_id})\n    return\n\nmain_1()\n\n## Solution 2\n## -----------------------------------------------------------------------------\nREQUEST_ID: str | None = None\n\ndef get_request_id() -&gt; str:\n    return REQUEST_ID\n\ndef generate_request_id():\n    global REQUEST_ID\n    REQUEST_ID = uuid.uuid4().hex\n\nclass RequestIdFilter(logging.Filter):\n    # Ref: https://docs.python.org/3/howto/logging-cookbook.html#using-filters-to-impart-contextual-information\n\n    def filter(self, record):\n        record.record_id = get_request_id()\n        return True\n\nrequest_id_filter = RequestIdFilter()\nlogger.addFilter(request_id_filter)\n\ndef main_2():\n    print(\"========== MAIN 2 ==========\")\n    for i in range(3):\n        generate_request_id()\n        logger.info(\"loop start\")\n        logger.info(f\"loop {i}\")\n        logger.info(\"loop end\")\n    return\n\nmain_2()\n\nlogger.removeFilter(request_id_filter)\n\n## Solution 3\n## -----------------------------------------------------------------------------\n# Reuse REQUEST_ID stuff from solution 2\nclass MyFormatter(JsonFormatter):\n    def process_log_record(self, log_record):\n        log_record[\"request_id\"] = get_request_id()\n        return log_record\n\nhandler.setFormatter(MyFormatter())\n\ndef main_3():\n    print(\"========== MAIN 3 ==========\")\n    for i in range(3):\n        generate_request_id()\n        logger.info(\"loop start\")\n        logger.info(f\"loop {i}\")\n        logger.info(\"loop end\")\n    return\n\nmain_3()\n</code></pre>"},{"location":"cookbook/#using-fileconfig","title":"Using <code>fileConfig</code>","text":"<p>To use the module with a config file using the <code>fileConfig</code> function, use the class <code>pythonjsonlogger.json.JsonFormatter</code>. Here is a sample config file.</p> <pre><code>[loggers]\nkeys = root,custom\n\n[logger_root]\nhandlers =\n\n[logger_custom]\nlevel = INFO\nhandlers = custom\nqualname = custom\n\n[handlers]\nkeys = custom\n\n[handler_custom]\nclass = StreamHandler\nlevel = INFO\nformatter = json\nargs = (sys.stdout,)\n\n[formatters]\nkeys = json\n\n[formatter_json]\nformat = %(message)s\nclass = pythonjsonlogger.jsonlogger.JsonFormatter\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>Note: All versions of this fork use version <code>&gt;=3.0.0</code> - to use pre-fork versions use <code>python-json-logger&lt;3.0.0</code>.</p>"},{"location":"quickstart/#install-via-pip","title":"Install via pip","text":"<p>Until the PEP 541 request is complete you will need to install directly from github.</p>"},{"location":"quickstart/#install-from-github","title":"Install from GitHub","text":"<p>To install from releases:</p> <pre><code># e.g. 3.0.0 wheel\npip install 'python-json-logger@https://github.com/nhairs/python-json-logger/releases/download/v3.0.0/python_json_logger-3.0.0-py3-none-any.whl'\n</code></pre>"},{"location":"quickstart/#usage","title":"Usage","text":"<p>Python JSON Logger provides <code>logging.Formatter</code>s that encode the logged message into JSON. Although a variety of JSON encoders are supported, in the following examples we will use the pythonjsonlogger.json.JsonFormatter which uses the the <code>json</code> module from the standard library.</p>"},{"location":"quickstart/#integrating-with-pythons-logging-framework","title":"Integrating with Python's logging framework","text":"<p>To produce JSON output, attach the formatter to a logging handler:</p> <pre><code>import logging\nfrom pythonjsonlogger.json import JsonFormatter\n\nlogger = logging.getLogger()\n\nlogHandler = logging.StreamHandler()\nformatter = JsonFormatter()\nlogHandler.setFormatter(formatter)\nlogger.addHandler(logHandler)\n</code></pre>"},{"location":"quickstart/#output-fields","title":"Output fields","text":""},{"location":"quickstart/#required-fields","title":"Required Fields","text":"<p>You can control the logged fields by setting the <code>fmt</code> argument when creating the formatter. By default formatters will follow the same <code>style</code> of <code>fmt</code> as the <code>logging</code> module: <code>%</code>, <code>$</code>, and <code>{</code>. All <code>LogRecord</code> attributes can be output using their name.</p> <pre><code>formatter = JsonFormatter(\"{message}{asctime}{exc_info}\", style=\"{\")\n</code></pre>"},{"location":"quickstart/#message-fields","title":"Message Fields","text":"<p>Instead of logging a string message you can log using a <code>dict</code>.</p> <pre><code>logger.info({\n    \"my_data\": 1,\n    \"message\": \"if you don't include this it will be an empty string\",\n    \"other_stuff\": False,\n})\n</code></pre> <p>Warning</p> <p>Be aware that if you log using a <code>dict</code>, other formatters may not be able to handle it.</p> <p>You can also add additional message fields using the <code>extra</code> argument.</p> <pre><code>logger.info(\n    \"this logs the same additional fields as above\",\n    extra={\n        \"my_data\": 1,\n        \"other_stuff\": False,\n    },\n)\n</code></pre> <p>Finally, any non-standard attributes added to a <code>LogRecord</code> will also be included in the logged data. See Cookbook: Request / Trace IDs for an example.</p>"},{"location":"quickstart/#static-fields","title":"Static Fields","text":"<p>Static fields that are added to every log record can be set using the <code>static_fields</code> argument.</p> <pre><code>formatter = JsonFormatter(\n    static_fields={\"True gets logged on every record?\": True}\n)\n</code></pre>"},{"location":"quickstart/#excluding-fields","title":"Excluding fields","text":"<p>You can prevent fields being added to the output data by adding them to <code>reserved_attrs</code>.</p> <pre><code>from pythonjsonlogger.core import RESERVED_ATTRS\n\nformatter = JsonFormatter(\n    reserved_attrs=RESERVED_ATTRS+[\"request_id\", \"my_other_field\"]\n)\n</code></pre>"},{"location":"quickstart/#renaming-fields","title":"Renaming fields","text":"<p>You can rename fields using the <code>rename_fields</code> argument.</p> <pre><code>formatter = JsonFormatter(\n    \"{message}{levelname}\",\n    style=\"{\",\n    rename_fields={\"levelname\": \"LEVEL\"},\n)\n</code></pre>"},{"location":"quickstart/#custom-object-serialization","title":"Custom object serialization","text":"<p>Most formatters support <code>json_default</code> which is used to control how objects are serialized.</p> <p>For custom handling of object serialization you can specify default json object translator or provide a custom encoder</p> <pre><code>def my_default(obj):\n    if isinstance(obj, MyClass):\n        return {\"special\": obj.special}\n\nformatter = JsonFormatter(json_default=my_default)\n</code></pre> <p>Note</p> <p>When providing your own <code>json_default</code>, you likely want to call the original <code>json_default</code> for your encoder. Python JSON Logger provides custom default serializers for each encoder that tries very hard to ensure sane output is always logged.</p>"},{"location":"quickstart/#alternate-json-encoders","title":"Alternate JSON Encoders","text":"<p>The following JSON encoders are also supported:</p> <ul> <li>orjson - pythonjsonlogger.orjson.OrjsonFormatter</li> <li>msgspec - pythonjsonlogger.msgspec.MsgspecFormatter</li> </ul>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#supported-versions","title":"Supported Versions","text":"<p>Security support for Python JSON Logger is provided for all security supported versions of Python and for unsupported versions of Python where recent downloads over the last 90 days exceeds 5% of all downloads.</p> <p>As of 2024-04-24 security support is provided for Python versions <code>3.8+</code>.</p>"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please report vulnerabilties using GitHub.</p>"},{"location":"reference/pythonjsonlogger/","title":"Index","text":""},{"location":"reference/pythonjsonlogger/#pythonjsonlogger","title":"pythonjsonlogger","text":""},{"location":"reference/pythonjsonlogger/core/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> core","text":""},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core","title":"pythonjsonlogger.core","text":"<p>Core functionality shared by all JSON loggers</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter","title":"BaseJsonFormatter","text":"<pre><code>BaseJsonFormatter(\n    fmt: Optional[str] = None,\n    datefmt: Optional[str] = None,\n    style: str = \"%\",\n    validate: bool = True,\n    *,\n    prefix: str = \"\",\n    rename_fields: Optional[Dict[str, str]] = None,\n    rename_fields_keep_missing: bool = False,\n    static_fields: Optional[Dict[str, Any]] = None,\n    reserved_attrs: Optional[Sequence[str]] = None,\n    timestamp: Union[bool, str] = False,\n    defaults: Optional[Dict[str, Any]] = None\n)\n</code></pre> <p>               Bases: <code>Formatter</code></p> <p>Base class for pythonjsonlogger formatters</p> <p>Must not be used directly</p> <p>New in 3.1</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>Optional[str]</code> <p>string representing fields to log</p> <code>None</code> <code>datefmt</code> <code>Optional[str]</code> <p>format to use when formatting <code>asctime</code> field</p> <code>None</code> <code>style</code> <code>str</code> <p>how to extract log fields from <code>fmt</code></p> <code>'%'</code> <code>validate</code> <code>bool</code> <p>validate <code>fmt</code> against style, if implementing a custom <code>style</code> you must set this to <code>False</code>.</p> <code>True</code> <code>defaults</code> <code>Optional[Dict[str, Any]]</code> <p>ignored - kept for compatibility with python 3.10+</p> <code>None</code> <code>prefix</code> <code>str</code> <p>an optional string prefix added at the beginning of the formatted string</p> <code>''</code> <code>rename_fields</code> <code>Optional[Dict[str, str]]</code> <p>an optional dict, used to rename field names in the output. Rename <code>message</code> to <code>@message</code>: <code>{'message': '@message'}</code></p> <code>None</code> <code>rename_fields_keep_missing</code> <code>bool</code> <p>When renaming fields, include missing fields in the output.</p> <code>False</code> <code>static_fields</code> <code>Optional[Dict[str, Any]]</code> <p>an optional dict, used to add fields with static values to all logs</p> <code>None</code> <code>reserved_attrs</code> <code>Optional[Sequence[str]]</code> <p>an optional list of fields that will be skipped when outputting json log record. Defaults to all log record attributes: http://docs.python.org/library/logging.html#logrecord-attributes</p> <code>None</code> <code>timestamp</code> <code>Union[bool, str]</code> <p>an optional string/boolean field to add a timestamp when outputting the json log record. If string is passed, timestamp will be added to log record using string as key. If True boolean is passed, timestamp key will be \"timestamp\". Defaults to False/off.</p> <code>False</code> <p>Changed in 3.1:</p> <ul> <li>you can now use custom values for style by setting validate to <code>False</code>.   The value is stored in <code>self._style</code> as a string. The <code>parse</code> method will need to be   overridden in order to support the new style.</li> <li>Renaming fields now preserves the order that fields were added in and avoids adding   missing fields. The original behaviour, missing fields have a value of <code>None</code>, is still   available by setting <code>rename_fields_keep_missing</code> to <code>True</code>.</li> </ul>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_record: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>Dict[str, Any]</code> <p>data that will be logged</p> required <code>record</code> <code>LogRecord</code> <p>the record to extract data from</p> required <code>message_dict</code> <code>Dict[str, Any]</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> required"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>the record to format</p> required"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.jsonify_log_record","title":"jsonify_log_record","text":"<pre><code>jsonify_log_record(log_record: LogRecord) -&gt; str\n</code></pre> <p>Convert this log record into a JSON string.</p> <p>Child classes MUST override this method.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>the data to serialize</p> required"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_record: LogRecord) -&gt; LogRecord\n</code></pre> <p>Custom processing of the log record.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>incoming data</p> required"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_record: LogRecord) -&gt; str\n</code></pre> <p>Returns the final representation of the log record.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>the log record</p> required"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.merge_record_extra","title":"merge_record_extra","text":"<pre><code>merge_record_extra(\n    record: LogRecord,\n    target: Dict,\n    reserved: Container[str],\n    rename_fields: Optional[Dict[str, str]] = None,\n) -&gt; Dict\n</code></pre> <p>Merges extra attributes from LogRecord object into target dictionary</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>logging.LogRecord</p> required <code>target</code> <code>Dict</code> <p>dict to update</p> required <code>reserved</code> <code>Container[str]</code> <p>dict or list with reserved keys to skip</p> required <code>rename_fields</code> <code>Optional[Dict[str, str]]</code> <p>an optional dict, used to rename field names in the output. e.g. Rename <code>levelname</code> to <code>log.level</code>: <code>{'levelname': 'log.level'}</code></p> <code>None</code> <p>Changed in 3.1: <code>reserved</code> is now <code>Container[str]</code>.</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.str_to_object","title":"str_to_object","text":"<pre><code>str_to_object(obj: Any) -&gt; Any\n</code></pre> <p>Import strings to an object, leaving non-strings as-is.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>the object or string to process</p> required <p>New in 3.1</p>"},{"location":"reference/pythonjsonlogger/defaults/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> defaults","text":""},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults","title":"pythonjsonlogger.defaults","text":""},{"location":"reference/pythonjsonlogger/json/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> json","text":""},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json","title":"pythonjsonlogger.json","text":"<p>JSON formatter using the standard library's <code>json</code> for encoding.</p> <p>Module contains the <code>JsonFormatter</code> and a custom <code>JsonEncoder</code> which supports a greater variety of types.</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonEncoder","title":"JsonEncoder","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>A custom encoder extending the default JSONEncoder</p> <p>Refs: - https://docs.python.org/3/library/json.html</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonEncoder.format_datetime_obj","title":"format_datetime_obj","text":"<pre><code>format_datetime_obj(o: time | date | datetime) -&gt; str\n</code></pre> <p>Format datetime objects found in self.default</p> <p>This allows subclasses to change the datetime format without understanding the internals of the default method.</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter","title":"JsonFormatter","text":"<pre><code>JsonFormatter(\n    *args,\n    json_default: OptionalCallableOrStr = None,\n    json_encoder: OptionalCallableOrStr = None,\n    json_serializer: Union[Callable, str] = json.dumps,\n    json_indent: Optional[Union[int, str]] = None,\n    json_ensure_ascii: bool = True,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>BaseJsonFormatter</code></p> <p>JSON formatter using the standard library's <code>json</code> for encoding</p> <p>Parameters:</p> Name Type Description Default <code>json_default</code> <code>OptionalCallableOrStr</code> <p>a function for encoding non-standard objects as outlined in https://docs.python.org/3/library/json.html</p> <code>None</code> <code>json_encoder</code> <code>OptionalCallableOrStr</code> <p>optional custom encoder</p> <code>None</code> <code>json_serializer</code> <code>Union[Callable, str]</code> <p>a :meth:<code>json.dumps</code>-compatible callable that will be used to serialize the log record.</p> <code>dumps</code> <code>json_indent</code> <code>Optional[Union[int, str]]</code> <p>indent parameter for json.dumps</p> <code>None</code> <code>json_ensure_ascii</code> <code>bool</code> <p>ensure_ascii parameter for json.dumps</p> <code>True</code>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_record: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>Dict[str, Any]</code> <p>data that will be logged</p> required <code>record</code> <code>LogRecord</code> <p>the record to extract data from</p> required <code>message_dict</code> <code>Dict[str, Any]</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> required"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>the record to format</p> required"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_record: LogRecord) -&gt; LogRecord\n</code></pre> <p>Custom processing of the log record.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>incoming data</p> required"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_record: LogRecord) -&gt; str\n</code></pre> <p>Returns the final representation of the log record.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>the log record</p> required"},{"location":"reference/pythonjsonlogger/msgspec/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> msgspec","text":""},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec","title":"pythonjsonlogger.msgspec","text":""},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter","title":"MsgspecFormatter","text":"<pre><code>MsgspecFormatter(\n    *args,\n    json_default: OptionalCallableOrStr = msgspec_default,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>BaseJsonFormatter</code></p> <p>JSON formatter using msgspec.json for encoding.</p> <p>Refs: - https://jcristharif.com/msgspec/api.html#msgspec.json.Encoder</p> <p>Parameters:</p> Name Type Description Default <code>json_default</code> <code>OptionalCallableOrStr</code> <p>a function for encoding non-standard objects see: <code>msgspec.json.Encode:enc_hook</code></p> <code>msgspec_default</code>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_record: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>Dict[str, Any]</code> <p>data that will be logged</p> required <code>record</code> <code>LogRecord</code> <p>the record to extract data from</p> required <code>message_dict</code> <code>Dict[str, Any]</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> required"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>the record to format</p> required"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.jsonify_log_record","title":"jsonify_log_record","text":"<pre><code>jsonify_log_record(log_record: LogRecord) -&gt; str\n</code></pre> <p>Returns a json string of the log record.</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_record: LogRecord) -&gt; LogRecord\n</code></pre> <p>Custom processing of the log record.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>incoming data</p> required"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_record: LogRecord) -&gt; str\n</code></pre> <p>Returns the final representation of the log record.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>the log record</p> required"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.msgspec_default","title":"msgspec_default","text":"<pre><code>msgspec_default(obj: Any) -&gt; Any\n</code></pre> <p>msgspec default encoder function for non-standard types</p>"},{"location":"reference/pythonjsonlogger/orjson/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> orjson","text":""},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson","title":"pythonjsonlogger.orjson","text":""},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter","title":"OrjsonFormatter","text":"<pre><code>OrjsonFormatter(\n    *args,\n    json_default: OptionalCallableOrStr = orjson_default,\n    json_indent: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>BaseJsonFormatter</code></p> <p>JSON formatter using orjson for encoding.</p> <p>Refs: - https://github.com/ijl/orjson</p> <p>Parameters:</p> Name Type Description Default <code>json_default</code> <code>OptionalCallableOrStr</code> <p>a function for encoding non-standard objects see: https://github.com/ijl/orjson#default</p> <code>orjson_default</code> <code>json_indent</code> <code>bool</code> <p>indent output with 2 spaces. see: https://github.com/ijl/orjson#opt_indent_2</p> <code>False</code>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_record: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>Dict[str, Any]</code> <p>data that will be logged</p> required <code>record</code> <code>LogRecord</code> <p>the record to extract data from</p> required <code>message_dict</code> <code>Dict[str, Any]</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> required"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>the record to format</p> required"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.jsonify_log_record","title":"jsonify_log_record","text":"<pre><code>jsonify_log_record(log_record: LogRecord) -&gt; str\n</code></pre> <p>Returns a json string of the log record.</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_record: LogRecord) -&gt; LogRecord\n</code></pre> <p>Custom processing of the log record.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>incoming data</p> required"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_record: LogRecord) -&gt; str\n</code></pre> <p>Returns the final representation of the log record.</p> <p>Parameters:</p> Name Type Description Default <code>log_record</code> <code>LogRecord</code> <p>the log record</p> required"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.orjson_default","title":"orjson_default","text":"<pre><code>orjson_default(obj: Any) -&gt; Any\n</code></pre> <p>orjson default encoder function for non-standard types</p>"}]}
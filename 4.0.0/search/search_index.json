{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python JSON Logger","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Python JSON Logger enables you produce JSON logs when using Python's <code>logging</code> package.</p> <p>JSON logs are machine readable allowing for much easier parsing and ingestion into log aggregation tools.</p> <p>This library assumes that you are famliar with the <code>logging</code> standard library package; if you are not you should start by reading the official Logging HOWTO.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Standard Library Compatible: Implement JSON logging without modifying your existing log setup.</li> <li>Supports Multiple JSON Encoders: In addition to the standard libary's <code>json</code> module, also supports the <code>orjson</code>, <code>msgspec</code> JSON encoders.</li> <li>Fully Customizable Output Fields: Control required, excluded, and static fields including automatically picking up custom attributes on <code>LogRecord</code> objects. Fields can be renamed before they are output.</li> <li>Encode Any Type: Encoders are customized to ensure that something sane is logged for any input including those that aren't supported by default. For example formatting UUID objects into their string representation and bytes objects into a base 64 encoded string.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Jump right in with our Quickstart Guide to get <code>python-json-logger</code> integrated into your project quickly.</p> <p>Here's a small taste of what it looks like:</p> Example Usage<pre><code>import logging\nfrom pythonjsonlogger.json import JsonFormatter\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\nhandler = logging.StreamHandler()\nhandler.setFormatter(JsonFormatter())\n\nlogger.addHandler(handler)\n\nlogger.info(\"Logging using python-json-logger!\", extra={\"more_data\": True})\n# {\"message\": \"Logging using python-json-logger!\", \"more_data\": true}\n</code></pre>"},{"location":"#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Quickstart Guide: For installation and basic setup.</li> <li>Cookbook: For more advanced usage patterns and recipes.</li> <li>API Reference: Dive into the details of specific formatters, functions, and classes (see navigation menu).</li> <li>Contributing Guidelines: If you'd like to contribute to the project.</li> <li>Changelog: To see what's new in recent versions.</li> </ul>"},{"location":"#project-information","title":"Project Information","text":""},{"location":"#bugs-feature-requests-etc","title":"Bugs, Feature Requests, etc.","text":"<p>Please submit an issue on GitHub.</p> <p>In the case of bug reports, please help us help you by following best practices <sup>1</sup> <sup>2</sup>.</p> <p>In the case of feature requests, please provide background to the problem you are trying to solve so that we can find a solution that makes the most sense for the library as well as your use case.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD 2 Clause License - see the LICENSE file on GitHub.</p>"},{"location":"#authors-and-maintainers","title":"Authors and Maintainers","text":"<p>This project was originally authored by Zakaria Zajac and our wonderful contributors.</p> <p>It is currently maintained by: - Nicholas Hairs - nicholashairs.com</p>"},{"location":"changelog/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#400-unreleased","title":"4.0.0 - UNRELEASED","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support <code>DictConfigurator</code> prefixes for <code>rename_fields</code> and <code>static_fields</code>. #45<ul> <li>Allows using values like <code>ext://sys.stderr</code> in <code>fileConfig</code>/<code>dictConfig</code> value fields.</li> </ul> </li> <li>Support comma seperated lists for Formatter <code>fmt</code> (<code>style=\",\"</code>) e.g. <code>\"asctime,message,levelname\"</code> #15<ul> <li>Note that this style is specific to <code>python-json-logger</code> and thus care should be taken not to pass this format to other logging Formatter implementations.</li> </ul> </li> <li>Supports sequences of strings (e.g. lists and tuples) of field names for Formatter <code>fmt</code>. #16</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Rename <code>pythonjsonlogger.core.LogRecord</code> and <code>log_record</code> arguments to avoid confusion / overlapping with <code>logging.LogRecord</code>. #38     - Affects arguments to <code>pythonjsonlogger.core.BaseJsonFormatter</code> (and any child classes).         - <code>serialize_log_record</code>         - <code>add_fields</code>         - <code>jsonify_log_record</code>         - <code>process_log_record</code>     - Note: functions referring to <code>log_record</code> have not had their function name changed.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Remove support for providing strings instead of objects when instantiating formatters. Instead use the <code>DictConfigurator</code> <code>ext://</code> prefix format when using <code>fileConfig</code>/<code>dictConfig</code>. #47     - Affects <code>pythonjsonlogger.json.JsonFormatter</code>: <code>json_default</code>, <code>json_encoder</code>, <code>json_serializer</code>.     - Affects <code>pythonjsonlogger.orjson.OrjsonFormatter</code>: <code>json_default</code>.     - Affects <code>pythonjsonlogger.msgspec.MsgspecFormatter</code>: <code>json_default</code>.</li> </ul> <p>Thanks @rubensa</p>"},{"location":"changelog/#330-2025-03-06","title":"3.3.0 - 2025-03-06","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li><code>exc_info_as_array</code> and <code>stack_info_as_array</code> options are added to <code>pythonjsonlogger.core.BaseJsonFormatter</code> allowing both to be encoded as list of lines instead of a single multi-line string. #35</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Remove <code>msgspec-python313-pre</code> from <code>dev</code> dependencies preventing potential RCE. Details: GHSA-wmxh-pxcx-9w24</li> </ul> <p>Thanks @1hakusai1 and @omnigodz</p>"},{"location":"changelog/#321-2024-12-16","title":"3.2.1 - 2024-12-16","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Import error on <code>import pythonjsonlogger.jsonlogger</code> #29</li> </ul>"},{"location":"changelog/#320-2024-12-11","title":"3.2.0 - 2024-12-11","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li><code>pythonjsonlogger.[ORJSON,MSGSPEC]_AVAILABLE</code> no longer imports the respective package when determining availability.</li> <li><code>pythonjsonlogger.[orjson,msgspec]</code> now throws a <code>pythonjsonlogger.exception.MissingPackageError</code> when required libraries are not available. These contain more information about what is missing whilst still being an <code>ImportError</code>.</li> <li><code>defaults</code> parameter is no longer ignored and now conforms to the standard library. Setting a defaults dictionary will add the specified keys if the those keys do not exist in a record or weren't passed by the <code>extra</code> parameter when logging a message.</li> <li><code>typing_extensions</code> is only installed on Python version &lt; 3.10.</li> <li>Support Python 3.13<ul> <li><code>msgspec</code> has only been tested against pre-release versions.</li> </ul> </li> </ul> <p>Thanks @cjwatson and @bharel</p>"},{"location":"changelog/#310-2023-05-28","title":"3.1.0 - 2023-05-28","text":"<p>This splits common funcitonality out to allow supporting other JSON encoders. Although this is a large refactor, backwards compatibility has been maintained.</p>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li><code>pythonjsonlogger.core</code> - more details below.</li> <li><code>pythonjsonlogger.defaults</code> module that provides many functions for handling unsupported types.</li> <li>Orjson encoder support via <code>pythonjsonlogger.orjson.OrjsonFormatter</code> with the following additions:<ul> <li>bytes are URL safe base64 encoded.</li> <li>Exceptions are \"pretty printed\" using the exception name and message e.g. <code>\"ValueError: bad value passed\"</code></li> <li>Enum values use their value, Enum classes now return all values as a list.</li> <li>Tracebacks are supported</li> <li>Classes (aka types) are support</li> <li>Will fallback on <code>__str__</code> if available, else <code>__repr__</code> if available, else will use <code>__could_not_encode__</code></li> </ul> </li> <li>MsgSpec encoder support via <code>pythonjsonlogger.msgspec.MsgspecFormatter</code> with the following additions:<ul> <li>Exceptions are \"pretty printed\" using the exception name and message e.g. <code>\"ValueError: bad value passed\"</code></li> <li>Enum classes now return all values as a list.</li> <li>Tracebacks are supported</li> <li>Classes (aka types) are support</li> <li>Will fallback on <code>__str__</code> if available, else <code>__repr__</code> if available, else will use <code>__could_not_encode__</code></li> <li>Note: msgspec only supprts enum values of type <code>int</code> or <code>str</code> jcrist/msgspec#680</li> </ul> </li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li><code>pythonjsonlogger.jsonlogger</code> has been moved to <code>pythonjsonlogger.json</code> with core functionality moved to <code>pythonjsonlogger.core</code>.</li> <li><code>pythonjsonlogger.core.BaseJsonFormatter</code> properly supports all <code>logging.Formatter</code> arguments:<ul> <li><code>fmt</code> is unchanged.</li> <li><code>datefmt</code> is unchanged.</li> <li><code>style</code> can now support non-standard arguments by setting <code>validate</code> to <code>False</code></li> <li><code>validate</code> allows non-standard <code>style</code> arguments or prevents calling <code>validate</code> on standard <code>style</code> arguments.</li> <li><code>default</code> is ignored.</li> </ul> </li> <li><code>pythonjsonlogger.json.JsonFormatter</code> default encodings changed:<ul> <li>bytes are URL safe base64 encoded.</li> <li>Exception formatting detected using <code>BaseException</code> instead of <code>Exception</code>. Now \"pretty prints\" the exception using the exception name and message e.g. <code>\"ValueError: bad value passed\"</code></li> <li>Dataclasses are now supported</li> <li>Enum values now use their value, Enum classes now return all values as a list.</li> <li>Will fallback on <code>__str__</code> if available, else <code>__repr__</code> if available, else will use <code>__could_not_encode__</code></li> </ul> </li> <li>Renaming fields now preserves order (#7) and ignores missing fields (#6).</li> <li>Documentation<ul> <li>Generated documentation using <code>mkdocs</code> is stored in <code>docs/</code></li> <li>Documentation within <code>README.md</code> has been moved to <code>docs/index.md</code> and <code>docs/qucikstart.md</code>.</li> <li><code>CHANGELOG.md</code> has been moved to <code>docs/change-log.md</code></li> <li><code>SECURITY.md</code> has been moved and replaced with a symbolic link to <code>docs/security.md</code>.</li> </ul> </li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>pythonjsonlogger.jsonlogger</code> is now <code>pythonjsonlogger.json</code></li> <li><code>pythonjsonlogger.jsonlogger.RESERVED_ATTRS</code> is now <code>pythonjsonlogger.core.RESERVED_ATTRS</code>.</li> <li><code>pythonjsonlogger.jsonlogger.merge_record_extra</code> is now <code>pythonjsonlogger.core.merge_record_extra</code>.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Python 3.7 support dropped</li> <li><code>pythonjsonlogger.jsonlogger.JsonFormatter._str_to_fn</code> replaced with <code>pythonjsonlogger.core.str_to_object</code>.</li> </ul>"},{"location":"changelog/#301-2023-04-01","title":"3.0.1 - 2023-04-01","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Fix spelling of parameter <code>json_serialiser</code> -&gt; <code>json_serializer</code> (#8) - @juliangilbey</li> </ul>"},{"location":"changelog/#300-2024-03-25","title":"3.0.0 - 2024-03-25","text":"<p>Note: using new major version to seperate changes from this fork and the original (upstream). See #1 for details.</p>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Update supported Python versions - @nhairs<ul> <li>Drop 3.6</li> <li>The following versions are supported and tested:<ul> <li>CPython 3.7-3.12 (ubuntu, windows, mac)</li> <li>PyPy 3.7-3.10 (ubuntu, wundows, mac)</li> </ul> </li> <li><code>RESERVED_ATTRS</code> is now a list and version dependent</li> </ul> </li> <li>Fix <code>JsonFormatter.__init__</code> return type (<code>None</code>) - @nhairs</li> <li>Moved to <code>pyproject.toml</code> - @nhairs</li> <li>Update linting and testing - @nhairs<ul> <li>Split lint and test steps in GHA</li> <li>Use validate-pyproject, black, pylint, mypy</li> </ul> </li> </ul>"},{"location":"changelog/#207-2023-02-21","title":"2.0.7 - 2023-02-21","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Fix inclusion of py.typed in pip packages - @sth</li> <li>Added pytest support with test file rename. Migrated to assertEqual</li> </ul>"},{"location":"changelog/#206-2023-02-14","title":"2.0.6 - 2023-02-14","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Parameter <code>rename_fields</code> in merge_record_extra is now optional - @afallou</li> </ul>"},{"location":"changelog/#205-2023-02-12","title":"2.0.5 - 2023-02-12","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Allow reserved attrs to be renamed - @henkhogan</li> <li>Support added for Python 3.11</li> <li>Now verifying builds in Pypy 3.9 as well</li> <li>Type annotations are now in the package - @louis-jaris</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Fix rename_fields for exc_info - @guilhermeferrari</li> <li>Cleaned up test file for PEP8 - @lopagela</li> <li>Cleaned up old Python 2 artifacts - @louis-jaris</li> <li>Dropped Python 3.5 support - @idomozes</li> <li>Moved type check via tox into 3.11 run only</li> <li>Added test run in Python3.6 (will keep for a little while longer, but it's EOL so upgrade)</li> </ul>"},{"location":"changelog/#204-2022-07-11","title":"2.0.4 - 2022-07-11","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Fix too strict regex for percentage style logging - @aberres</li> </ul>"},{"location":"changelog/#203-2022-07-08","title":"2.0.3 - 2022-07-08","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Add PEP 561 marker/basic mypy configuration. - @bringhurst</li> <li>Workaround logging.LogRecord.msg type of string. - @bringhurst</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Changed a link archive of the reference page in case it's down. - @ahonnecke</li> <li>Removed unnecessary try-except around OrderedDict usage - @sozofaan</li> <li>Update documentation link to json module + use https - @deronnax</li> <li>Dropped 3.5 support. - @bringhurst</li> </ul>"},{"location":"changelog/#202-2021-07-27","title":"2.0.2 - 2021-07-27","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Officially supporting 3.9 - @felixonmars.</li> <li>You can now add static fields to log objects - @cosimomeli.</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Dropped 3.4 support.</li> <li>Dropped Travis CI for Github Actions.</li> <li>Wheel should build for python 3 instead of just 3.4 now.</li> </ul>"},{"location":"changelog/#201-2020-10-12","title":"2.0.1 - 2020-10-12","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Support Pypi long descripton - @ereli-cb</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>You can now rename output fields - @schlitzered</li> </ul>"},{"location":"changelog/#200-2020-09-26","title":"2.0.0 - 2020-09-26","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>New Changelog</li> <li>Added timezone support to timestamps - @lalten</li> <li>Refactored log record to function - @georgysavva</li> <li>Add python 3.8 support - @tommilligan</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Support for Python 2.7</li> <li>Debian directory</li> </ul>"},{"location":"changelog/#0111-2019-03-29","title":"0.1.11 - 2019-03-29","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Support for Python 3.7</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>'stack_info' flag in logging calls is now respected in JsonFormatter by @ghShu</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome!</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>In general we follow the Python Software Foundation Code of Conduct. Please note that we are not affiliated with the PSF.</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<p>0. Before you begin</p> <p>If you're not familiar with contributing to open source software, start by reading this guide.</p> <p>Be aware that anything you contribute will be licenced under the project's licence. If you are making a change as a part of your job, be aware that your employer might own your work and you'll need their permission in order to licence the code.</p>"},{"location":"contributing/#1-find-something-to-work-on","title":"1. Find something to work on","text":"<p>Where possible it's best to stick to established issues where discussion has already taken place. Contributions that haven't come from a discussed issue are less likely to be accepted.</p> <p>The following are things that can be worked on without an existing issue:</p> <ul> <li>Updating documentation. This includes fixing in-code documentation / comments, and the overall docs.</li> <li>Small changes that don't change functionality such as refactoring or adding / updating tests.</li> </ul>"},{"location":"contributing/#2-fork-the-repository-and-make-your-changes","title":"2. Fork the repository and make your changes","text":""},{"location":"contributing/#coding-style","title":"Coding Style","text":"<p>Before writing any code, please familiarize yourself with our Python Style Guide. This document outlines our coding conventions, formatting expectations, and common patterns used in the project. Adhering to this guide is crucial for maintaining code consistency and readability.</p> <p>While the style guide covers detailed conventions, always try to match the style of existing code in the module you are working on, especially regarding local patterns and structure.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>All devlopment tooling can be installed (usually into a virtual environment), using the <code>dev</code> optional dependency:</p> <pre><code>pip install -e '.[dev]'`\n</code></pre> <p>Before creating your pull request you'll want to format your code and run the linters and tests:</p> <pre><code># Format\nblack src tests\n\n# Lint\npylint --output-format=colorized src\nmypy src tests\n\n# Tests\npytest\n</code></pre> <p>The above commands (<code>black</code>, <code>pylint</code>, <code>mypy</code>, <code>pytest</code>) should all be run before submitting a pull request.</p> <p>If making changes to the documentation you can preview the changes locally using <code>mkdocs</code>. Changes to the <code>README.md</code> can be previewed using a tool like <code>grip</code> (installable via <code>pip install grip</code>).</p> <pre><code>mkdocs serve\n# For README preview (after installing grip):\n# grip\n</code></pre> <p>Note</p> <p>In general we will always squash merge pull requests so you do not need to worry about a \"clean\" commit history.</p>"},{"location":"contributing/#3-checklist","title":"3. Checklist","text":"<p>Before pushing and creating your pull request, you should make sure you've done the following:</p> <ul> <li>Updated any relevant tests.</li> <li>Formatted your code and run the linters and tests.</li> <li>Updated the version number in <code>pyproject.toml</code>. In general using a <code>.devN</code> suffix is acceptable.   This is not required for changes that do no affect the code such as documentation.</li> <li>Add details of the changes to the change log (<code>docs/change-log.md</code>), creating a new section if needed.</li> <li>Add notes for new / changed features in the relevant docstring.</li> </ul> <p>4. Create your pull request</p> <p>When creating your pull request be aware that the title and description will be used for the final commit so pay attention to them.</p> <p>Your pull request description should include the following:</p> <ul> <li>Why the pull request is being made</li> <li>Summary of changes</li> <li>How the pull request was tested - especially if not covered by unit testing.</li> </ul> <p>Once you've submitted your pull request make sure that all CI jobs are passing. Pull requests with failing jobs will not be reviewed.</p>"},{"location":"contributing/#5-code-review","title":"5. Code review","text":"<p>Your code will be reviewed by a maintainer.</p> <p>If you're not familiar with code review start by reading this guide.</p> <p>Remember you are not your work</p> <p>You might be asked to explain or justify your choices. This is not a criticism of your value as a person!</p> <p>Often this is because there are multiple ways to solve the same problem and the reviewer would like to understand more about the way you solved.</p>"},{"location":"contributing/#common-topics","title":"Common Topics","text":""},{"location":"contributing/#adding-a-new-encoder","title":"Adding a new encoder","text":"<p>New encoders may be added, however how popular / common a library is will be taken into consideration before being added. You should open an issue before creating a pull request.</p>"},{"location":"contributing/#versioning-and-breaking-compatability","title":"Versioning and breaking compatability","text":"<p>This project uses semantic versioning.</p> <p>In general backwards compatability is always preferred. This library is widely used and not particularly sophisticated and as such there must be a good reason for breaking changes.</p> <p>Feature changes MUST be compatible with all security supported versions of Python and SHOULD be compatible with all unsupported versions of Python where recent downloads over the last 90 days exceeds 5% of all downloads.</p> <p>In general, only the latest <code>major.minor</code> version of Python JSON Logger is supported. Bug fixes and feature backports requiring a version branch may be considered but must be discussed with the maintainers first.</p> <p>See also Security Policy.</p>"},{"location":"contributing/#spelling","title":"Spelling","text":"<p>The original implementation of this project used US spelling so it will continue to use US spelling for all code.</p> <p>Documentation is more flexible and may use a variety of English spellings.</p>"},{"location":"contributing/#contacting-the-maintainers","title":"Contacting the Maintainers","text":"<p>In general it is preferred to keep communication to GitHub, e.g. through comments on issues and pull requests. If you do need to contact the maintainers privately, please do so using the email addresses in the maintainers section of the <code>pyproject.toml</code>.</p>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Recipies for common tasks.</p>"},{"location":"cookbook/#include-all-fields","title":"Include all fields","text":"<p>By default Python JSON Logger will not include fields defined in the standard library unless they are included in the format. Manually including all these fields is tedious and Python version specific. Instead of adding them as explicit fields, we can add them implicitly be ensuring they are not in the <code>reserver_attrs</code> argument of the formatter.</p> <pre><code>all_fields_formatter = JsonFormatter(reserved_attrs=[])\n</code></pre>"},{"location":"cookbook/#custom-styles","title":"Custom Styles","text":"<p>It is possible to support custom <code>style</code>s by setting <code>validate=False</code> and overriding the <code>parse</code> method.</p> <p>For example:</p> <pre><code>class CommaSupport(JsonFormatter):\n    def parse(self) -&gt; list[str]:\n        if isinstance(self._style, str) and self._style == \",\":\n            return self._fmt.split(\",\")\n        return super().parse()\n\nformatter = CommaSupport(\"message,asctime\", style=\",\", validate=False)\n</code></pre>"},{"location":"cookbook/#modifying-the-logged-data","title":"Modifying the logged data","text":"<p>You can modify the <code>dict</code> of data that will be logged by overriding the <code>process_log_record</code> method to modify fields before they are serialized to JSON.</p> <pre><code>class SillyFormatter(JsonFormatter):\n    def process_log_record(log_data):\n        new_record = {k[::-1]: v for k, v in log_data.items()}\n        return new_record\n</code></pre>"},{"location":"cookbook/#request-trace-ids","title":"Request / Trace IDs","text":"<p>There are many ways to add consistent request IDs to your logging. The exact method will depend on your needs and application.</p> <pre><code>## Common Setup\n## -----------------------------------------------------------------------------\nimport logging\nimport uuid\nfrom pythonjsonlogger.json import JsonFormatter\n\nlogger = logging.getLogger(\"test\")\nlogger.setLevel(logging.INFO)\nhandler = logging.StreamHandler()\nlogger.addHandler(handler)\n</code></pre> <p>One method would be to inject the request ID into each log call using the <code>extra</code> argument. <pre><code>## Solution 1\n## -----------------------------------------------------------------------------\nformatter = JsonFormatter()\nhandler.setFormatter(formatter)\n\ndef main_1():\n    print(\"========== MAIN 1 ==========\")\n    for i in range(3):\n        request_id = uuid.uuid4()\n        logger.info(\"loop start\", extra={\"request_id\": request_id})\n        logger.info(f\"loop {i}\", extra={\"request_id\": request_id})\n        logger.info(\"loop end\", extra={\"request_id\": request_id})\n    return\n\nmain_1()\n</code></pre></p> <p>Another method would be to use a filter to modify the <code>LogRecord</code> attributes. This would also allow us to use it in any other standard logging machinery. For this example I've manually set a <code>REQUEST_ID</code> global and some helper functions, but you might already have stuff available to you; for example, if you're using a web-framework with baked in request IDs.</p> <p>This is based on the logging cookbook filter recipie.</p> <pre><code>## Solution 2\n## -----------------------------------------------------------------------------\nREQUEST_ID: str | None = None\n\ndef get_request_id() -&gt; str:\n    return REQUEST_ID\n\ndef generate_request_id():\n    global REQUEST_ID\n    REQUEST_ID = str(uuid.uuid4())\n\nclass RequestIdFilter(logging.Filter):\n    def filter(self, record):\n        record.request_id = get_request_id() # Add request_id to the LogRecord\n        return True\n\nrequest_id_filter = RequestIdFilter()\nlogger.addFilter(request_id_filter)\n\ndef main_2():\n    print(\"========== MAIN 2 ==========\")\n    for i in range(3):\n        generate_request_id()\n        logger.info(\"loop start\")\n        logger.info(f\"loop {i}\")\n        logger.info(\"loop end\")\n    return\n\nmain_2()\n\nlogger.removeFilter(request_id_filter)\n</code></pre> <p>Another method would be to create a custom formatter class and override the <code>process_log_record</code> method. This allows us to inject fields into the record before we log it without modifying the original <code>LogRecord</code>.</p> <pre><code>## Solution 3\n## -----------------------------------------------------------------------------\n# Reuse REQUEST_ID stuff from solution 2\nclass MyFormatter(JsonFormatter):\n    def process_log_record(self, log_data):\n        log_data[\"request_id\"] = get_request_id()\n        return log_data\n\nhandler.setFormatter(MyFormatter())\n\ndef main_3():\n    print(\"========== MAIN 3 ==========\")\n    for i in range(3):\n        generate_request_id()\n        logger.info(\"loop start\")\n        logger.info(f\"loop {i}\")\n        logger.info(\"loop end\")\n    return\n\nmain_3()\n</code></pre>"},{"location":"cookbook/#using-fileconfig","title":"Using <code>fileConfig</code>","text":"<p>To use the module with a yaml config file using the <code>fileConfig</code> function, use the class <code>pythonjsonlogger.json.JsonFormatter</code>. Here is a sample config file:</p> example_config.yaml<pre><code>version: 1\ndisable_existing_loggers: False\nformatters:\n  default:\n    \"()\": pythonjsonlogger.json.JsonFormatter\n    format: \"%(asctime)s %(levelname)s %(name)s %(module)s %(funcName)s %(lineno)s %(message)s\"\n    json_default: ext://logging_config.my_json_default\n    rename_fields:\n      \"asctime\": \"timestamp\"\n      \"levelname\": \"status\"\n    static_fields:\n      \"service\": ext://logging_config.PROJECT_NAME\n      \"env\": ext://logging_config.ENVIRONMENT\n      \"version\": ext://logging_config.PROJECT_VERSION\n      \"app_log\": \"true\"\nhandlers:\n  default:\n    formatter: default\n    class: logging.StreamHandler\n    stream: ext://sys.stderr\n  access:\n    formatter: default\n    class: logging.StreamHandler\n    stream: ext://sys.stdout\nloggers:\n  uvicorn.error:\n    level: INFO\n    handlers:\n      - default\n    propagate: no\n  uvicorn.access:\n    level: INFO\n    handlers:\n      - access\n    propagate: no\n</code></pre> <p>You'll notice that we are using <code>ext://...</code> for <code>json_default</code> and<code>static_fields</code>. This will load data from other modules such as the one below.</p> logging_config.py<pre><code>import importlib.metadata\nimport os\n\n\nclass Dummy:\n    pass\n\n\ndef my_json_default(obj: Any) -&gt; Any:\n    if isinstance(obj, Dummy):\n        return \"DUMMY\"\n    return obj\n\n\ndef get_version_metadata():\n    # https://stackoverflow.com/a/78082532\n    version = importlib.metadata.version(PROJECT_NAME)\n    return version\n\n\nPROJECT_NAME = 'test-api'\nPROJECT_VERSION = get_version_metadata()\nENVIRONMENT = os.environ.get('ENVIRONMENT', 'dev')\n</code></pre>"},{"location":"cookbook/#logging-expensive-to-compute-data","title":"Logging Expensive to Compute Data","text":"<p>By the nature of Python's logging library, the JSON formatters will only ever run in handlers which are enabled for the given log level. This saves the performance hit of constructing JSON that is never used - but what about the data we pass into the logger? There are two options available to us: using if statements to avoid the call altogether, or using lazy string evaluation libraries.</p> <p>Note</p> <p>The below strategies will work for data passed in the <code>msg</code> and <code>extra</code> arguments.</p> <p>To avoid the logging calls we use <code>logger.isEnabledFor</code> to ensure that we only start constructing our log messages if the logger is enabled:</p> <pre><code>import logging\nimport time\n\nfrom pythonjsonlogger.json import JsonFormatter\n\ndef expensive_to_compute():\n    time.sleep(5)\n    return \"world\"\n\n## Setup\n## -------------------------------------\nlogger = logging.getLogger()\nhandler = logging.StreamHandler()\nformatter = JsonFormatter()\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\n## Log Using isEnabledFor\n## -------------------------------------\nstart = time.time()\nif logger.isEnabledFor(logging.INFO):\n    logger.info(\n        {\n            \"data\": \"hello {}\".format(expensive_to_compute())\n        }\n    )\nprint(f\"Logging INFO using isEnabledFor took: {int(time.time() - start)}s\")\n\nstart = time.time()\nif logger.isEnabledFor(logging.DEBUG):\n    logger.debug(\n        {\n            \"data\": \"hello {}\".format(expensive_to_compute())\n        }\n    )\nprint(f\"Logging DEBUG using isEnabledFor took: {int(time.time() - start)}s\")\n</code></pre> <p>For lazy string evaluation we can take advantage of the fact that the default JSON encoders included in this package will call <code>str</code> on unkown objects. We can use this to build our own lazy string evaluators, or we can use an existing external package. Pre-existing solutions include: <code>lazy-string</code>'s <code>LazyString</code> or <code>stringlike</code>'s <code>CachedLazyString</code>.</p> <pre><code>## Log Using lazy-string\n## -------------------------------------\nfrom lazy_string import LazyString as L\n\nstart = time.time()\nlogger.info(\n    {\n        \"data\": L(\"hello {}\".format, L(expensive_to_compute))\n    }\n)\nprint(f\"Logging INFO using LazyString took: {int(time.time() - start)}s\")\n\nstart = time.time()\nlogger.debug(\n    {\n        \"data\": L(\"hello {}\".format, L(expensive_to_compute))\n    }\n)\nprint(f\"Logging DEBUG using LazyString took: {int(time.time() - start)}s\")\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>Note</p> <p>All versions of this fork use version <code>&gt;=3.0.0</code>.</p> <p>To use pre-fork versions use <code>python-json-logger&lt;3</code>.</p>"},{"location":"quickstart/#install-via-pip","title":"Install via pip","text":"<pre><code>pip install python-json-logger\n</code></pre>"},{"location":"quickstart/#install-from-github","title":"Install from GitHub","text":"<p>To install from releases (including development releases), you can use the URL to the specific wheel.</p> <pre><code># e.g. 3.0.0 wheel\npip install 'python-json-logger@https://github.com/nhairs/python-json-logger/releases/download/v3.0.0/python_json_logger-3.0.0-py3-none-any.whl'\n</code></pre>"},{"location":"quickstart/#usage","title":"Usage","text":"<p>Python JSON Logger provides <code>logging.Formatter</code> classes that encode the logged message into JSON. Although a variety of JSON encoders are supported, the following examples will use the JsonFormatter which uses the the <code>json</code> module from the standard library.</p>"},{"location":"quickstart/#integrating-with-pythons-logging-framework","title":"Integrating with Python's logging framework","text":"<p>To produce JSON output, attach the formatter to a logging handler:</p> <pre><code>import logging\nfrom pythonjsonlogger.json import JsonFormatter\n\nlogger = logging.getLogger()\n\nlogHandler = logging.StreamHandler()\nformatter = JsonFormatter()\nlogHandler.setFormatter(formatter)\nlogger.addHandler(logHandler)\n</code></pre>"},{"location":"quickstart/#output-fields","title":"Output fields","text":""},{"location":"quickstart/#required-fields","title":"Required Fields","text":"<p>You can control the logged fields by setting the <code>fmt</code> argument when creating the formatter. A variety of different formats are supported including:</p> <ul> <li>Standard library formats: where <code>style</code> is one of <code>%</code>, <code>$</code>, or <code>{</code>. This allows using Python JSON Logger Formatters with your existing config.</li> <li>Comma format: where <code>style</code> is <code>,</code> which simplifies the writing of formats where you can't use more complex formats.</li> <li>A sequence of string: e.g. lists or tuples.</li> </ul> <p>All <code>LogRecord</code> attributes can be output using their name.</p> <pre><code># Standard library format\nformatter = JsonFormatter(\"{message}{asctime}{exc_info}\", style=\"{\")\n\n# Comma format\nformatter = JsonFormatter(\"message,asctime,exc_info\", style=\",\")\n\n# Sequence of strings format\nformatter = JsonFormatter([\"message\", \"asctime\", \"exc_info\"])\n</code></pre>"},{"location":"quickstart/#message-fields","title":"Message Fields","text":"<p>Instead of logging a string message you can log using a <code>dict</code>.</p> <pre><code>logger.info({\n    \"my_data\": 1,\n    \"message\": \"if you don't include this it will be an empty string\",\n    \"other_stuff\": False,\n})\n</code></pre> <p>Warning</p> <p>Be aware that if you log using a <code>dict</code>, other formatters may not be able to handle it.</p> <p>You can also add additional message fields using the <code>extra</code> argument.</p> <pre><code>logger.info(\n    \"this logs the same additional fields as above\",\n    extra={\n        \"my_data\": 1,\n        \"other_stuff\": False,\n    },\n)\n</code></pre> <p>Finally, any non-standard attributes added to a <code>LogRecord</code> will also be included in the logged data. See Cookbook: Request / Trace IDs for an example.</p>"},{"location":"quickstart/#default-fields","title":"Default Fields","text":"<p>Default fields that are added to every log record prior to any other field can be set using the <code>default</code> argument.</p> <pre><code>formatter = JsonFormatter(\n    defaults={\"environment\": \"dev\"}\n)\n# ...\nlogger.info(\"this message will have environment=dev by default\")\nlogger.info(\"this overwrites the environment field\", extra={\"environment\": \"prod\"})\n</code></pre>"},{"location":"quickstart/#static-fields","title":"Static Fields","text":"<p>Static fields that are added to every log record can be set using the <code>static_fields</code> argument.</p> <pre><code>formatter = JsonFormatter(\n    static_fields={\"True gets logged on every record?\": True}\n)\n</code></pre>"},{"location":"quickstart/#excluding-fields","title":"Excluding fields","text":"<p>You can prevent fields being added to the output data by adding them to <code>reserved_attrs</code>. By default all <code>LogRecord</code> attributes are excluded.</p> <pre><code>from pythonjsonlogger.core import RESERVED_ATTRS\n\nformatter = JsonFormatter(\n    reserved_attrs=RESERVED_ATTRS+[\"request_id\", \"my_other_field\"]\n)\n</code></pre>"},{"location":"quickstart/#renaming-fields","title":"Renaming fields","text":"<p>You can rename fields using the <code>rename_fields</code> argument.</p> <pre><code>formatter = JsonFormatter(\n    \"{message}{levelname}\",\n    style=\"{\",\n    rename_fields={\"levelname\": \"LEVEL\"},\n)\n</code></pre>"},{"location":"quickstart/#custom-object-serialization","title":"Custom object serialization","text":"<p>Most formatters support <code>json_default</code> which is used to control how objects are serialized.</p> <pre><code>def my_default(obj):\n    if isinstance(obj, MyClass):\n        return {\"special\": obj.special}\n\nformatter = JsonFormatter(json_default=my_default)\n</code></pre> <p>Note</p> <p>When providing your own <code>json_default</code>, you likely want to call the original <code>json_default</code> for your encoder. Python JSON Logger provides custom default serializers for each encoder that tries very hard to ensure sane output is always logged.</p>"},{"location":"quickstart/#alternate-json-encoders","title":"Alternate JSON Encoders","text":"<p>The following JSON encoders are also supported:</p> <ul> <li>orjson - pythonjsonlogger.orjson.OrjsonFormatter</li> <li>msgspec - pythonjsonlogger.msgspec.MsgspecFormatter</li> </ul>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#supported-versions","title":"Supported Versions","text":"<p>Security support for Python JSON Logger is provided for all security supported versions of Python and for unsupported versions of Python where recent downloads over the last 90 days exceeds 5% of all downloads.</p> <p>As of 2024-04-24 security support is provided for Python versions <code>3.8+</code>.</p>"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please report vulnerabilties using GitHub.</p>"},{"location":"style-guide/","title":"Python Style Guide","text":"<p>This document outlines the coding style, conventions, and common patterns for the <code>python-json-logger</code> project. Adhering to this guide will help maintain code consistency, readability, and quality.</p>"},{"location":"style-guide/#general-principles","title":"General Principles","text":"<ul> <li>Readability Counts: Write code that is easy for others (and your future self) to understand. This aligns with PEP 20 (The Zen of Python).</li> <li>Consistency: Strive for consistency in naming, formatting, and structure throughout the codebase.</li> <li>Simplicity: Prefer simple, straightforward solutions over overly complex ones.</li> <li>PEP 8: Follow PEP 8 (Style Guide for Python Code) for all Python code. The automated tools mentioned below will enforce many of these rules. This guide highlights project-specific conventions or particularly important PEP 8 aspects.</li> </ul>"},{"location":"style-guide/#formatting-and-linting","title":"Formatting and Linting","text":"<p>We use automated tools to enforce a consistent code style and catch potential errors. These include:</p> <ul> <li>Black: For opinionated code formatting.</li> <li>Pylint: For static code analysis and error detection.</li> <li>MyPy: For static type checking.</li> </ul> <p>Ensure these tools are run before committing code. Configuration for these tools can be found in <code>pyproject.toml</code>, <code>pylintrc</code>, and <code>mypy.ini</code> respectively. This guide primarily focuses on conventions not automatically verifiable by these tools.</p>"},{"location":"style-guide/#imports","title":"Imports","text":"<p>Imports should be structured into the following groups, separated by a blank line, and generally alphabetized within each group:</p> <ol> <li>Future Imports: e.g., <code>from __future__ import annotations</code></li> <li>Standard Library Imports: e.g., <code>import sys</code>, <code>from datetime import datetime</code></li> <li>Installed (Third-Party) Library Imports: e.g., <code>import pytest</code></li> <li>Application (Local) Imports: e.g., <code>from .core import BaseJsonFormatter</code> (This project-specific pattern is crucial for internal organization).</li> </ol>"},{"location":"style-guide/#naming-conventions","title":"Naming Conventions","text":"<p>While PEP 8 covers most naming, we emphasize:</p> <ul> <li>Modules: <code>lowercase_with_underscores.py</code></li> <li>Packages: <code>lowercase</code></li> <li>Classes &amp; Type Aliases: <code>CapWords</code> (e.g., <code>BaseJsonFormatter</code>, <code>OptionalCallableOrStr</code>). This is standard, but explicitly stated for clarity.</li> <li>Constants: <code>UPPERCASE_WITH_UNDERSCORES</code> (e.g., <code>RESERVED_ATTRS</code>). This is a project convention for module-level constants.</li> </ul> <p>(Functions, methods, and variables follow standard PEP 8 <code>lowercase_with_underscores</code>).</p>"},{"location":"style-guide/#comments","title":"Comments","text":"<ul> <li>Use comments to explain non-obvious code, complex logic, or important design decisions. Avoid comments that merely restate what the code does.</li> <li>For internal code organization within files, especially in longer modules or classes, use comments like <code>## Section Title ##</code> or <code>### Subsection Title ###</code> to delineate logical blocks of code (e.g., <code>## Parent Methods ##</code> as seen in <code>src/pythonjsonlogger/core.py</code>). This is distinct from Markdown headings used in this document.</li> </ul>"},{"location":"style-guide/#docstrings","title":"Docstrings","text":"<ul> <li>All public modules, classes, functions, and methods must have docstrings.</li> <li>We use <code>mkdocstrings</code> for generating API documentation, which defaults to the Google Python Style Guide for docstrings. Please adhere to this style. You can find the guide here.</li> <li>Docstrings should clearly explain the purpose, arguments, return values, and any exceptions raised.</li> <li>Project Convention: Use the following markers to indicate changes over time:     *   <code>*New in version_number*</code>: For features added in a specific version.     *   <code>*Changed in version_number*</code>: For changes made in a specific version.     *   <code>*Deprecated in version_number*</code>: For features deprecated in a specific version.<p>Example:   <pre><code>def my_function(param1: str, param2: int) -&gt; bool:\n    \"\"\"Does something interesting.\n\n    Args:\n        param1: The first parameter, a string.\n        param2: The second parameter, an integer.\n\n    Returns:\n        True if successful, False otherwise.\n\n    Raises:\n        ValueError: If param2 is negative.\n\n    *New in 3.1*\n    \"\"\"\n    # ... function logic ...\n    return True # See 'Return Statements'\n</code></pre></p> </li> </ul>"},{"location":"style-guide/#type-hinting","title":"Type Hinting","text":"<ul> <li>All new code must include type hints for function arguments, return types, and variables where appropriate, as per PEP 484.</li> <li>Use standard types from the <code>typing</code> module.</li> <li>Project Convention: For Python versions older than 3.10, use <code>typing_extensions.TypeAlias</code> for creating type aliases. For Python 3.10+, use <code>typing.TypeAlias</code> (e.g., <code>OptionalCallableOrStr: TypeAlias = ...</code>).</li> </ul>"},{"location":"style-guide/#return-statements","title":"Return Statements","text":"<ul> <li>Project Convention: All functions and methods must have an explicit <code>return</code> statement.</li> <li>If a function does not logically return a value, it should end with <code>return None</code> or simply <code>return</code>. This makes the intent clear and consistent across the codebase.<p>Example:   <pre><code>def process_data(data: dict) -&gt; None:\n    \"\"\"Processes the given data.\"\"\"\n    # ... processing logic ...\n    print(data)\n    return # or return None\n</code></pre></p> </li> </ul>"},{"location":"style-guide/#class-structure","title":"Class Structure","text":"<ul> <li>Group methods logically within a class (e.g., initialization, public, protected/private, special methods).</li> <li>The use of internal code comments like <code>## Parent Methods ##</code> (as seen in <code>src/pythonjsonlogger/core.py</code>) is encouraged for readability in complex classes.</li> </ul>"},{"location":"style-guide/#project-specific-code-patterns-and-idioms","title":"Project-Specific Code Patterns and Idioms","text":"<p>Familiarize yourself with these patterns commonly used in this project:</p> <ul> <li>Version-Specific Logic: Using <code>sys.version_info</code> for compatibility:     <pre><code>if sys.version_info &gt;= (3, 10):\n    # Python 3.10+ specific code\nelse:\n    # Code for older versions\n</code></pre></li> <li>Type Aliases for Clarity: As mentioned in Type Hinting, using <code>TypeAlias</code> for complex type combinations improves readability.</li> <li>Custom Exceptions: Defining custom exception classes for application-specific error conditions (e.g., <code>MissingPackageError</code> in <code>src/pythonjsonlogger/exception.py</code>).</li> <li>Helper/Utility Functions: Encapsulating reusable logic in utility modules (e.g., functions in <code>src/pythonjsonlogger/utils.py</code>).</li> <li>Conditional Imports for Optional Dependencies: The pattern in <code>src/pythonjsonlogger/__init__.py</code> for checking optional dependencies like <code>orjson</code> and <code>msgspec</code> using <code>package_is_available</code> from <code>utils.py</code>.</li> </ul>"},{"location":"style-guide/#testing","title":"Testing","text":"<p>This project uses <code>pytest</code> for testing. Adherence to good testing practices is crucial.</p> <ul> <li>Test Location: Tests are located in the <code>tests/</code> directory.</li> <li>Test Naming: Test files <code>test_*.py</code>; test functions <code>test_*</code>.</li> <li>Fixtures: Utilize <code>pytest</code> fixtures (<code>@pytest.fixture</code>) for setup.     *   Project Pattern: The <code>LoggingEnvironment</code> dataclass and <code>env</code> fixture in <code>tests/test_formatters.py</code> is a key pattern for testing logger behavior. Adapt this for similar scenarios.</li> <li>Parametrization: Use <code>@pytest.mark.parametrize</code> extensively to cover multiple scenarios efficiently.</li> <li>Clarity and Focus: Each test should be focused and its name descriptive.</li> <li>Assertions: Use clear, specific <code>pytest</code> assertions.</li> </ul> <p>By following these guidelines, we can ensure that <code>python-json-logger</code> remains a high-quality, maintainable, and developer-friendly library.</p>"},{"location":"reference/pythonjsonlogger/","title":"Index","text":""},{"location":"reference/pythonjsonlogger/#pythonjsonlogger","title":"pythonjsonlogger","text":"MODULE DESCRIPTION <code>core</code> <p>Core functionality shared by all JSON loggers</p> <code>defaults</code> <p>Collection of functions for building custom <code>json_default</code> functions.</p> <code>exception</code> <code>json</code> <p>JSON formatter using the standard library's <code>json</code> for encoding.</p> <code>jsonlogger</code> <p>Stub module retained for compatibility.</p> <code>msgspec</code> <p>JSON Formatter using <code>msgspec</code></p> <code>orjson</code> <p>JSON Formatter using orjson</p> <code>utils</code> <p>Utilities for Python JSON Logger</p>"},{"location":"reference/pythonjsonlogger/core/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> core","text":""},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core","title":"pythonjsonlogger.core","text":"<p>Core functionality shared by all JSON loggers</p> CLASS DESCRIPTION <code>BaseJsonFormatter</code> <p>Base class for all formatters</p> FUNCTION DESCRIPTION <code>merge_record_extra</code> <p>Merges extra attributes from LogRecord object into target dictionary</p> ATTRIBUTE DESCRIPTION <code>LogData</code> <p>Type alias</p> <p> TYPE: <code>TypeAlias</code> </p> <code>RESERVED_ATTRS</code> <p>Default reserved attributes.</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.LogData","title":"LogData  <code>module-attribute</code>","text":"<pre><code>LogData: TypeAlias = Dict[str, Any]\n</code></pre> <p>Type alias</p> <p>Changed in 4.0: renamed from <code>LogRecord</code> to <code>LogData</code></p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.RESERVED_ATTRS","title":"RESERVED_ATTRS  <code>module-attribute</code>","text":"<pre><code>RESERVED_ATTRS: List[str] = [\n    \"args\",\n    \"asctime\",\n    \"created\",\n    \"exc_info\",\n    \"exc_text\",\n    \"filename\",\n    \"funcName\",\n    \"levelname\",\n    \"levelno\",\n    \"lineno\",\n    \"module\",\n    \"msecs\",\n    \"message\",\n    \"msg\",\n    \"name\",\n    \"pathname\",\n    \"process\",\n    \"processName\",\n    \"relativeCreated\",\n    \"stack_info\",\n    \"thread\",\n    \"threadName\",\n]\n</code></pre> <p>Default reserved attributes.</p> <p>These come from the default attributes of <code>LogRecord</code> objects.</p> Note <p>Although considered a constant, this list is dependent on the Python version due to different <code>LogRecord</code> objects having different attributes in different Python versions.</p> <p>Changed in 3.0: <code>RESERVED_ATTRS</code> is now <code>list[str]</code> instead of <code>tuple[str, ...]</code>.</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter","title":"BaseJsonFormatter","text":"<pre><code>BaseJsonFormatter(\n    fmt: Optional[Union[str, Sequence[str]]] = None,\n    datefmt: Optional[str] = None,\n    style: str = \"%\",\n    validate: bool = True,\n    *,\n    prefix: str = \"\",\n    rename_fields: Optional[Dict[str, str]] = None,\n    rename_fields_keep_missing: bool = False,\n    static_fields: Optional[Dict[str, Any]] = None,\n    reserved_attrs: Optional[Sequence[str]] = None,\n    timestamp: Union[bool, str] = False,\n    defaults: Optional[Dict[str, Any]] = None,\n    exc_info_as_array: bool = False,\n    stack_info_as_array: bool = False\n)\n</code></pre> <p>               Bases: <code>Formatter</code></p> <p>Base class for all formatters</p> <p>Must not be used directly.</p> <p>New in 3.1</p> <p>Changed in 3.2: <code>defaults</code> argument is no longer ignored.</p> <p>Added in 3.3: <code>exc_info_as_array</code> and <code>stack_info_as_array</code> options are added.</p> PARAMETER DESCRIPTION <code>fmt</code> <p>String format or <code>Sequence</code> of field names of fields to log.</p> <p> TYPE: <code>Optional[Union[str, Sequence[str]]]</code> DEFAULT: <code>None</code> </p> <code>datefmt</code> <p>format to use when formatting <code>asctime</code> field</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>style</code> <p>how to extract log fields from <code>fmt</code>. Ignored if <code>fmt</code> is a <code>Sequence[str]</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'%'</code> </p> <code>validate</code> <p>validate <code>fmt</code> against style, if implementing a custom <code>style</code> you must set this to <code>False</code>. Ignored if <code>fmt</code> is a <code>Sequence[str]</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>defaults</code> <p>a dictionary containing default fields that are added before all other fields and may be overridden. The supplied fields are still subject to <code>rename_fields</code>.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>prefix</code> <p>an optional string prefix added at the beginning of the formatted string</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>rename_fields</code> <p>an optional dict, used to rename field names in the output. Rename <code>message</code> to <code>@message</code>: <code>{'message': '@message'}</code></p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>rename_fields_keep_missing</code> <p>When renaming fields, include missing fields in the output.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>static_fields</code> <p>an optional dict, used to add fields with static values to all logs</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>reserved_attrs</code> <p>an optional list of fields that will be skipped when outputting json log record. Defaults to all log record attributes.</p> <p> TYPE: <code>Optional[Sequence[str]]</code> DEFAULT: <code>None</code> </p> <code>timestamp</code> <p>an optional string/boolean field to add a timestamp when outputting the json log record. If string is passed, timestamp will be added to log record using string as key. If True boolean is passed, timestamp key will be \"timestamp\". Defaults to False/off.</p> <p> TYPE: <code>Union[bool, str]</code> DEFAULT: <code>False</code> </p> <code>exc_info_as_array</code> <p>break the exc_info into a list of lines based on line breaks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>stack_info_as_array</code> <p>break the stack_info into a list of lines based on line breaks.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Changed in 3.1:</p> <ul> <li>you can now use custom values for style by setting validate to <code>False</code>.   The value is stored in <code>self._style</code> as a string. The <code>parse</code> method will need to be   overridden in order to support the new style.</li> <li>Renaming fields now preserves the order that fields were added in and avoids adding   missing fields. The original behaviour, missing fields have a value of <code>None</code>, is still   available by setting <code>rename_fields_keep_missing</code> to <code>True</code>.</li> </ul> <p>Added in 4.0:</p> <ul> <li><code>fmt</code> now supports comma seperated lists (<code>style=\",\"</code>). Note that this style is specific   to <code>python-json-logger</code> and thus care should be taken to not to pass this format to other   logging Formatter implementations.</li> <li><code>fmt</code> now supports sequences of strings (e.g. lists and tuples) of field names.</li> </ul> METHOD DESCRIPTION <code>add_fields</code> <p>Extract fields from a LogRecord for logging</p> <code>format</code> <p>Formats a log record and serializes to json</p> <code>formatException</code> <p>Format and return the specified exception information.</p> <code>formatStack</code> <p>Format and return the specified stack information.</p> <code>jsonify_log_record</code> <p>Convert the log data into a JSON string.</p> <code>parse</code> <p>Parses format string looking for substitutions</p> <code>process_log_record</code> <p>Custom processing of the data to be logged.</p> <code>serialize_log_record</code> <p>Returns the final representation of the data to be logged</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_data: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>data that will be logged</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>record</code> <p>the record to extract data from</p> <p> TYPE: <code>LogRecord</code> </p> <code>message_dict</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> <p> TYPE: <code>Dict[str, Any]</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> PARAMETER DESCRIPTION <code>record</code> <p>the record to format</p> <p> TYPE: <code>LogRecord</code> </p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.formatException","title":"formatException","text":"<pre><code>formatException(ei) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified exception information.</p> <p>If exc_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.formatStack","title":"formatStack","text":"<pre><code>formatStack(stack_info) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified stack information.</p> <p>If stack_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.jsonify_log_record","title":"jsonify_log_record","text":"<pre><code>jsonify_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Convert the log data into a JSON string.</p> <p>Child classes MUST override this method.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>the data to serialize</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_data: LogData) -&gt; LogData\n</code></pre> <p>Custom processing of the data to be logged.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>incoming data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.BaseJsonFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Returns the final representation of the data to be logged</p> PARAMETER DESCRIPTION <code>log_data</code> <p>the data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/core/#pythonjsonlogger.core.merge_record_extra","title":"merge_record_extra","text":"<pre><code>merge_record_extra(\n    record: LogRecord,\n    target: Dict,\n    reserved: Container[str],\n    rename_fields: Optional[Dict[str, str]] = None,\n) -&gt; Dict\n</code></pre> <p>Merges extra attributes from LogRecord object into target dictionary</p> PARAMETER DESCRIPTION <code>record</code> <p>logging.LogRecord</p> <p> TYPE: <code>LogRecord</code> </p> <code>target</code> <p>dict to update</p> <p> TYPE: <code>Dict</code> </p> <code>reserved</code> <p>dict or list with reserved keys to skip</p> <p> TYPE: <code>Container[str]</code> </p> <code>rename_fields</code> <p>an optional dict, used to rename field names in the output. e.g. Rename <code>levelname</code> to <code>log.level</code>: <code>{'levelname': 'log.level'}</code></p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <p>Changed in 3.1: <code>reserved</code> is now <code>Container[str]</code>.</p>"},{"location":"reference/pythonjsonlogger/defaults/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> defaults","text":""},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults","title":"pythonjsonlogger.defaults","text":"<p>Collection of functions for building custom <code>json_default</code> functions.</p> <p>In general functions come in pairs of <code>use_x_default</code> and <code>x_default</code>, where the former is used to determine if you should call the latter.</p> <p>Most <code>use_x_default</code> functions also act as a <code>TypeGuard</code>.</p> FUNCTION DESCRIPTION <code>bytes_default</code> <p>Default function for bytes</p> <code>dataclass_default</code> <p>Default function for dataclass instances</p> <code>date_default</code> <p>Default function for <code>datetime.date</code> instances</p> <code>datetime_any</code> <p>Default function for <code>datetime</code> related instances</p> <code>datetime_default</code> <p>Default function for <code>datetime.datetime</code> instances</p> <code>enum_default</code> <p>Default function for enums.</p> <code>exception_default</code> <p>Default function for exception instances</p> <code>time_default</code> <p>Default function for <code>datetime.time</code> instances</p> <code>traceback_default</code> <p>Default function for tracebacks</p> <code>type_default</code> <p>Default function for <code>type</code> objects.</p> <code>unknown_default</code> <p>Backup default function for any object type.</p> <code>use_bytes_default</code> <p>Default check function for bytes</p> <code>use_dataclass_default</code> <p>Default check function for dataclass instances</p> <code>use_date_default</code> <p>Default check function for <code>datetime.date</code> instances</p> <code>use_datetime_any</code> <p>Default check function for <code>datetime</code> related instances</p> <code>use_datetime_default</code> <p>Default check function for <code>datetime.datetime</code> instances</p> <code>use_enum_default</code> <p>Default check function for enums.</p> <code>use_exception_default</code> <p>Default check function for exception instances.</p> <code>use_time_default</code> <p>Default check function for <code>datetime.time</code> instances</p> <code>use_traceback_default</code> <p>Default check function for tracebacks</p> <code>use_type_default</code> <p>Default check function for <code>type</code> objects (aka classes).</p> <code>use_uuid_default</code> <p>Default check function for <code>uuid.UUID</code> instances</p> <code>uuid_default</code> <p>Default function for <code>uuid.UUID</code> instances</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.bytes_default","title":"bytes_default","text":"<pre><code>bytes_default(\n    obj: bytes | bytearray, url_safe: bool = True\n) -&gt; str\n</code></pre> <p>Default function for bytes</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>bytes | bytearray</code> </p> <code>url_safe</code> <p>use URL safe base 64 character set.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The byte data as a base 64 string.</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.dataclass_default","title":"dataclass_default","text":"<pre><code>dataclass_default(obj) -&gt; dict[str, Any]\n</code></pre> <p>Default function for dataclass instances</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.date_default","title":"date_default","text":"<pre><code>date_default(obj: date) -&gt; str\n</code></pre> <p>Default function for <code>datetime.date</code> instances</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>date</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.datetime_any","title":"datetime_any","text":"<pre><code>datetime_any(obj: time | date | date) -&gt; str\n</code></pre> <p>Default function for <code>datetime</code> related instances</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>time | date | date</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.datetime_default","title":"datetime_default","text":"<pre><code>datetime_default(obj: datetime) -&gt; str\n</code></pre> <p>Default function for <code>datetime.datetime</code> instances</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>datetime</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.enum_default","title":"enum_default","text":"<pre><code>enum_default(obj: Enum | EnumMeta) -&gt; Any | list[Any]\n</code></pre> <p>Default function for enums.</p> <p>Supports both enum classes and enum values.</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>Enum | EnumMeta</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.exception_default","title":"exception_default","text":"<pre><code>exception_default(obj: BaseException) -&gt; str\n</code></pre> <p>Default function for exception instances</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>BaseException</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.time_default","title":"time_default","text":"<pre><code>time_default(obj: time) -&gt; str\n</code></pre> <p>Default function for <code>datetime.time</code> instances</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>time</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.traceback_default","title":"traceback_default","text":"<pre><code>traceback_default(obj: TracebackType) -&gt; str\n</code></pre> <p>Default function for tracebacks</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>TracebackType</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.type_default","title":"type_default","text":"<pre><code>type_default(obj: type) -&gt; str\n</code></pre> <p>Default function for <code>type</code> objects.</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>type</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.unknown_default","title":"unknown_default","text":"<pre><code>unknown_default(obj: Any) -&gt; str\n</code></pre> <p>Backup default function for any object type.</p> <p>Will attempt to use <code>str</code> or <code>repr</code>. If both functions error will return the string <code>\"__could_not_encode__\"</code>.</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>Any</code> </p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_bytes_default","title":"use_bytes_default","text":"<pre><code>use_bytes_default(obj: Any) -&gt; TypeGuard[bytes | bytearray]\n</code></pre> <p>Default check function for bytes</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_dataclass_default","title":"use_dataclass_default","text":"<pre><code>use_dataclass_default(obj: Any) -&gt; bool\n</code></pre> <p>Default check function for dataclass instances</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_date_default","title":"use_date_default","text":"<pre><code>use_date_default(obj: Any) -&gt; TypeGuard[date]\n</code></pre> <p>Default check function for <code>datetime.date</code> instances</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_datetime_any","title":"use_datetime_any","text":"<pre><code>use_datetime_any(\n    obj: Any,\n) -&gt; TypeGuard[time | date | datetime]\n</code></pre> <p>Default check function for <code>datetime</code> related instances</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_datetime_default","title":"use_datetime_default","text":"<pre><code>use_datetime_default(obj: Any) -&gt; TypeGuard[datetime]\n</code></pre> <p>Default check function for <code>datetime.datetime</code> instances</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_enum_default","title":"use_enum_default","text":"<pre><code>use_enum_default(obj: Any) -&gt; TypeGuard[Enum | EnumMeta]\n</code></pre> <p>Default check function for enums.</p> <p>Supports both enum classes and enum values.</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_exception_default","title":"use_exception_default","text":"<pre><code>use_exception_default(obj: Any) -&gt; TypeGuard[BaseException]\n</code></pre> <p>Default check function for exception instances.</p> <p>Exception classes are not treated specially and should be handled by the <code>[use_]type_default</code> functions.</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_time_default","title":"use_time_default","text":"<pre><code>use_time_default(obj: Any) -&gt; TypeGuard[time]\n</code></pre> <p>Default check function for <code>datetime.time</code> instances</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_traceback_default","title":"use_traceback_default","text":"<pre><code>use_traceback_default(obj: Any) -&gt; TypeGuard[TracebackType]\n</code></pre> <p>Default check function for tracebacks</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_type_default","title":"use_type_default","text":"<pre><code>use_type_default(obj: Any) -&gt; TypeGuard[type]\n</code></pre> <p>Default check function for <code>type</code> objects (aka classes).</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.use_uuid_default","title":"use_uuid_default","text":"<pre><code>use_uuid_default(obj: Any) -&gt; TypeGuard[UUID]\n</code></pre> <p>Default check function for <code>uuid.UUID</code> instances</p>"},{"location":"reference/pythonjsonlogger/defaults/#pythonjsonlogger.defaults.uuid_default","title":"uuid_default","text":"<pre><code>uuid_default(obj: UUID) -&gt; str\n</code></pre> <p>Default function for <code>uuid.UUID</code> instances</p> <p>Formats the UUID using \"hyphen\" format.</p> PARAMETER DESCRIPTION <code>obj</code> <p>object to handle</p> <p> TYPE: <code>UUID</code> </p>"},{"location":"reference/pythonjsonlogger/exception/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> exception","text":""},{"location":"reference/pythonjsonlogger/exception/#pythonjsonlogger.exception","title":"pythonjsonlogger.exception","text":"CLASS DESCRIPTION <code>MissingPackageError</code> <p>A required package is missing</p> <code>PythonJsonLoggerError</code> <p>Generic base clas for all Python JSON Logger exceptions</p>"},{"location":"reference/pythonjsonlogger/exception/#pythonjsonlogger.exception.MissingPackageError","title":"MissingPackageError","text":"<pre><code>MissingPackageError(\n    name: str, extras_name: str | None = None\n)\n</code></pre> <p>               Bases: <code>ImportError</code>, <code>PythonJsonLoggerError</code></p> <p>A required package is missing</p>"},{"location":"reference/pythonjsonlogger/exception/#pythonjsonlogger.exception.PythonJsonLoggerError","title":"PythonJsonLoggerError","text":"<p>               Bases: <code>Exception</code></p> <p>Generic base clas for all Python JSON Logger exceptions</p>"},{"location":"reference/pythonjsonlogger/json/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> json","text":""},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json","title":"pythonjsonlogger.json","text":"<p>JSON formatter using the standard library's <code>json</code> for encoding.</p> <p>Module contains the <code>JsonFormatter</code> and a custom <code>JsonEncoder</code> which supports a greater variety of types.</p> CLASS DESCRIPTION <code>JsonEncoder</code> <p>A custom encoder extending json.JSONEncoder</p> <code>JsonFormatter</code> <p>JSON formatter using the standard library's <code>json</code> for encoding</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonEncoder","title":"JsonEncoder","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>A custom encoder extending json.JSONEncoder</p> METHOD DESCRIPTION <code>format_datetime_obj</code> <p>Format datetime objects found in <code>self.default</code></p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonEncoder.format_datetime_obj","title":"format_datetime_obj","text":"<pre><code>format_datetime_obj(o: time | date | datetime) -&gt; str\n</code></pre> <p>Format datetime objects found in <code>self.default</code></p> <p>This allows subclasses to change the datetime format without understanding the internals of the default method.</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter","title":"JsonFormatter","text":"<pre><code>JsonFormatter(\n    *args,\n    json_default: Optional[Callable] = None,\n    json_encoder: Optional[Callable] = None,\n    json_serializer: Callable = dumps,\n    json_indent: Optional[Union[int, str]] = None,\n    json_ensure_ascii: bool = True,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>BaseJsonFormatter</code></p> <p>JSON formatter using the standard library's <code>json</code> for encoding</p> PARAMETER DESCRIPTION <code>args</code> <p>see BaseJsonFormatter</p> <p> DEFAULT: <code>()</code> </p> <code>json_default</code> <p>a function for encoding non-standard objects</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>json_encoder</code> <p>custom JSON encoder</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>None</code> </p> <code>json_serializer</code> <p>a <code>json.dumps</code>-compatible callable that will be used to serialize the log record.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>dumps</code> </p> <code>json_indent</code> <p>indent parameter for the <code>json_serializer</code></p> <p> TYPE: <code>Optional[Union[int, str]]</code> DEFAULT: <code>None</code> </p> <code>json_ensure_ascii</code> <p><code>ensure_ascii</code> parameter for the <code>json_serializer</code></p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>see BaseJsonFormatter</p> <p> DEFAULT: <code>{}</code> </p> METHOD DESCRIPTION <code>add_fields</code> <p>Extract fields from a LogRecord for logging</p> <code>format</code> <p>Formats a log record and serializes to json</p> <code>formatException</code> <p>Format and return the specified exception information.</p> <code>formatStack</code> <p>Format and return the specified stack information.</p> <code>jsonify_log_record</code> <p>Returns a json string of the log data.</p> <code>parse</code> <p>Parses format string looking for substitutions</p> <code>process_log_record</code> <p>Custom processing of the data to be logged.</p> <code>serialize_log_record</code> <p>Returns the final representation of the data to be logged</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_data: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>data that will be logged</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>record</code> <p>the record to extract data from</p> <p> TYPE: <code>LogRecord</code> </p> <code>message_dict</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> <p> TYPE: <code>Dict[str, Any]</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> PARAMETER DESCRIPTION <code>record</code> <p>the record to format</p> <p> TYPE: <code>LogRecord</code> </p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.formatException","title":"formatException","text":"<pre><code>formatException(ei) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified exception information.</p> <p>If exc_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.formatStack","title":"formatStack","text":"<pre><code>formatStack(stack_info) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified stack information.</p> <p>If stack_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.jsonify_log_record","title":"jsonify_log_record","text":"<pre><code>jsonify_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Returns a json string of the log data.</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_data: LogData) -&gt; LogData\n</code></pre> <p>Custom processing of the data to be logged.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>incoming data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/json/#pythonjsonlogger.json.JsonFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Returns the final representation of the data to be logged</p> PARAMETER DESCRIPTION <code>log_data</code> <p>the data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/jsonlogger/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> jsonlogger","text":""},{"location":"reference/pythonjsonlogger/jsonlogger/#pythonjsonlogger.jsonlogger","title":"pythonjsonlogger.jsonlogger","text":"<p>Stub module retained for compatibility.</p> <p>It retains access to old names whilst sending deprecation warnings.</p>"},{"location":"reference/pythonjsonlogger/msgspec/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> msgspec","text":""},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec","title":"pythonjsonlogger.msgspec","text":"<p>JSON Formatter using <code>msgspec</code></p> CLASS DESCRIPTION <code>MsgspecFormatter</code> <p>JSON formatter using <code>msgspec.json.Encoder</code> for encoding.</p> FUNCTION DESCRIPTION <code>msgspec_default</code> <p>msgspec default encoder function for non-standard types</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter","title":"MsgspecFormatter","text":"<pre><code>MsgspecFormatter(\n    *args,\n    json_default: Optional[Callable] = msgspec_default,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>BaseJsonFormatter</code></p> <p>JSON formatter using <code>msgspec.json.Encoder</code> for encoding.</p> PARAMETER DESCRIPTION <code>args</code> <p>see BaseJsonFormatter</p> <p> DEFAULT: <code>()</code> </p> <code>json_default</code> <p>a function for encoding non-standard objects</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>msgspec_default</code> </p> <code>kwargs</code> <p>see BaseJsonFormatter</p> <p> DEFAULT: <code>{}</code> </p> METHOD DESCRIPTION <code>add_fields</code> <p>Extract fields from a LogRecord for logging</p> <code>format</code> <p>Formats a log record and serializes to json</p> <code>formatException</code> <p>Format and return the specified exception information.</p> <code>formatStack</code> <p>Format and return the specified stack information.</p> <code>jsonify_log_record</code> <p>Returns a json string of the log data.</p> <code>parse</code> <p>Parses format string looking for substitutions</p> <code>process_log_record</code> <p>Custom processing of the data to be logged.</p> <code>serialize_log_record</code> <p>Returns the final representation of the data to be logged</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_data: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>data that will be logged</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>record</code> <p>the record to extract data from</p> <p> TYPE: <code>LogRecord</code> </p> <code>message_dict</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> <p> TYPE: <code>Dict[str, Any]</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> PARAMETER DESCRIPTION <code>record</code> <p>the record to format</p> <p> TYPE: <code>LogRecord</code> </p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.formatException","title":"formatException","text":"<pre><code>formatException(ei) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified exception information.</p> <p>If exc_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.formatStack","title":"formatStack","text":"<pre><code>formatStack(stack_info) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified stack information.</p> <p>If stack_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.jsonify_log_record","title":"jsonify_log_record","text":"<pre><code>jsonify_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Returns a json string of the log data.</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_data: LogData) -&gt; LogData\n</code></pre> <p>Custom processing of the data to be logged.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>incoming data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.MsgspecFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Returns the final representation of the data to be logged</p> PARAMETER DESCRIPTION <code>log_data</code> <p>the data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/msgspec/#pythonjsonlogger.msgspec.msgspec_default","title":"msgspec_default","text":"<pre><code>msgspec_default(obj: Any) -&gt; Any\n</code></pre> <p>msgspec default encoder function for non-standard types</p>"},{"location":"reference/pythonjsonlogger/orjson/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> orjson","text":""},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson","title":"pythonjsonlogger.orjson","text":"<p>JSON Formatter using orjson</p> CLASS DESCRIPTION <code>OrjsonFormatter</code> <p>JSON formatter using orjson for encoding.</p> FUNCTION DESCRIPTION <code>orjson_default</code> <p>orjson default encoder function for non-standard types</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter","title":"OrjsonFormatter","text":"<pre><code>OrjsonFormatter(\n    *args,\n    json_default: Optional[Callable] = orjson_default,\n    json_indent: bool = False,\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>BaseJsonFormatter</code></p> <p>JSON formatter using orjson for encoding.</p> PARAMETER DESCRIPTION <code>args</code> <p>see BaseJsonFormatter</p> <p> DEFAULT: <code>()</code> </p> <code>json_default</code> <p>a function for encoding non-standard objects</p> <p> TYPE: <code>Optional[Callable]</code> DEFAULT: <code>orjson_default</code> </p> <code>json_indent</code> <p>indent output with 2 spaces.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>kwargs</code> <p>see BaseJsonFormatter</p> <p> DEFAULT: <code>{}</code> </p> METHOD DESCRIPTION <code>add_fields</code> <p>Extract fields from a LogRecord for logging</p> <code>format</code> <p>Formats a log record and serializes to json</p> <code>formatException</code> <p>Format and return the specified exception information.</p> <code>formatStack</code> <p>Format and return the specified stack information.</p> <code>jsonify_log_record</code> <p>Returns a json string of the log data.</p> <code>parse</code> <p>Parses format string looking for substitutions</p> <code>process_log_record</code> <p>Custom processing of the data to be logged.</p> <code>serialize_log_record</code> <p>Returns the final representation of the data to be logged</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.add_fields","title":"add_fields","text":"<pre><code>add_fields(\n    log_data: Dict[str, Any],\n    record: LogRecord,\n    message_dict: Dict[str, Any],\n) -&gt; None\n</code></pre> <p>Extract fields from a LogRecord for logging</p> <p>This method can be overridden to implement custom logic for adding fields.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>data that will be logged</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>record</code> <p>the record to extract data from</p> <p> TYPE: <code>LogRecord</code> </p> <code>message_dict</code> <p>dictionary that was logged instead of a message. e.g <code>logger.info({\"is_this_message_dict\": True})</code></p> <p> TYPE: <code>Dict[str, Any]</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Formats a log record and serializes to json</p> PARAMETER DESCRIPTION <code>record</code> <p>the record to format</p> <p> TYPE: <code>LogRecord</code> </p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.formatException","title":"formatException","text":"<pre><code>formatException(ei) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified exception information.</p> <p>If exc_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.formatStack","title":"formatStack","text":"<pre><code>formatStack(stack_info) -&gt; Union[str, list[str]]\n</code></pre> <p>Format and return the specified stack information.</p> <p>If stack_info_as_array is set to True, This method returns an array of strings.</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.jsonify_log_record","title":"jsonify_log_record","text":"<pre><code>jsonify_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Returns a json string of the log data.</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.parse","title":"parse","text":"<pre><code>parse() -&gt; List[str]\n</code></pre> <p>Parses format string looking for substitutions</p> <p>This method is responsible for returning a list of fields (as strings) to include in all log messages.</p> <p>You can support custom styles by overriding this method.</p> RETURNS DESCRIPTION <code>List[str]</code> <p>list of fields to be extracted and serialized</p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.process_log_record","title":"process_log_record","text":"<pre><code>process_log_record(log_data: LogData) -&gt; LogData\n</code></pre> <p>Custom processing of the data to be logged.</p> <p>Child classes can override this method to alter the log record before it is serialized.</p> PARAMETER DESCRIPTION <code>log_data</code> <p>incoming data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.OrjsonFormatter.serialize_log_record","title":"serialize_log_record","text":"<pre><code>serialize_log_record(log_data: LogData) -&gt; str\n</code></pre> <p>Returns the final representation of the data to be logged</p> PARAMETER DESCRIPTION <code>log_data</code> <p>the data</p> <p> TYPE: <code>LogData</code> </p> <p>Changed in 4.0: <code>log_record</code> renamed to <code>log_data</code></p>"},{"location":"reference/pythonjsonlogger/orjson/#pythonjsonlogger.orjson.orjson_default","title":"orjson_default","text":"<pre><code>orjson_default(obj: Any) -&gt; Any\n</code></pre> <p>orjson default encoder function for non-standard types</p>"},{"location":"reference/pythonjsonlogger/utils/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utils","text":""},{"location":"reference/pythonjsonlogger/utils/#pythonjsonlogger.utils","title":"pythonjsonlogger.utils","text":"<p>Utilities for Python JSON Logger</p> FUNCTION DESCRIPTION <code>package_is_available</code> <p>Determine if the given package is available for import.</p>"},{"location":"reference/pythonjsonlogger/utils/#pythonjsonlogger.utils.package_is_available","title":"package_is_available","text":"<pre><code>package_is_available(\n    name: str,\n    *,\n    throw_error: bool = False,\n    extras_name: str | None = None\n) -&gt; bool\n</code></pre> <p>Determine if the given package is available for import.</p> PARAMETER DESCRIPTION <code>name</code> <p>Import name of the package to check.</p> <p> TYPE: <code>str</code> </p> <code>throw_error</code> <p>Throw an error if the package is unavailable.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>extras_name</code> <p>Extra dependency name to use in <code>throw_error</code>'s message.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>MissingPackageError</code> <p>When <code>throw_error</code> is <code>True</code> and the return value would be <code>False</code></p> RETURNS DESCRIPTION <code>bool</code> <p>If the package is available for import.</p>"}]}